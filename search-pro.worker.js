const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:n})=>n),bt=et(V(JSON.parse("{\"/\":{\"documentCount\":200,\"nextId\":200,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1@0\",\"3\":\"2\",\"4\":\"2@0\",\"5\":\"2@1\",\"6\":\"3\",\"7\":\"3@0\",\"8\":\"3@1\",\"9\":\"4\",\"10\":\"4#markdown-介绍\",\"11\":\"4#markdown-配置\",\"12\":\"4#markdown-扩展\",\"13\":\"4#vuepress-扩展\",\"14\":\"4#主题扩展\",\"15\":\"4#提示容器\",\"16\":\"4#代码块\",\"17\":\"4#上下角标\",\"18\":\"4#自定义对齐\",\"19\":\"4#attrs\",\"20\":\"4#脚注\",\"21\":\"4#标记\",\"22\":\"4#任务列表\",\"23\":\"4#图片增强\",\"24\":\"4#组件\",\"25\":\"4@0\",\"26\":\"4@1\",\"27\":\"5\",\"28\":\"5#页面标题\",\"29\":\"5#页面信息\",\"30\":\"5#页面内容\",\"31\":\"5#组件\",\"32\":\"5@0\",\"33\":\"5@1\",\"34\":\"6\",\"35\":\"6#功能亮点\",\"36\":\"6#bar\",\"37\":\"6#foo\",\"38\":\"7\",\"39\":\"7#目录\",\"40\":\"7#基础篇\",\"41\":\"7@0\",\"42\":\"7@1\",\"43\":\"8\",\"44\":\"8@0\",\"45\":\"9\",\"46\":\"9#目录\",\"47\":\"9#数据结构篇\",\"48\":\"9#持久化篇\",\"49\":\"9#策略篇\",\"50\":\"9#高可用篇\",\"51\":\"9#缓存篇\",\"52\":\"9#应用篇\",\"53\":\"9#面试篇\",\"54\":\"9@0\",\"55\":\"10\",\"56\":\"10#介绍\",\"57\":\"10#详情\",\"58\":\"11\",\"59\":\"12\",\"60\":\"12#介绍\",\"61\":\"12#详情\",\"62\":\"13\",\"63\":\"14\",\"64\":\"14@0\",\"65\":\"15\",\"66\":\"15#锁\",\"67\":\"15#单节点分布式锁\",\"68\":\"15#给锁加超时时间\",\"69\":\"15#使用加参数的set\",\"70\":\"15#给锁添加唯一标识\",\"71\":\"15#删除锁-原子性操作\",\"72\":\"15#redlock\",\"73\":\"15#watchdog的设计原则\",\"74\":\"15@0\",\"75\":\"16\",\"76\":\"16#布隆过滤器\",\"77\":\"16@0\",\"78\":\"17\",\"79\":\"17#aof日志\",\"80\":\"17#aof写回策略\",\"81\":\"17#aof重写机制\",\"82\":\"17#aof后台重写\",\"83\":\"17@0\",\"84\":\"18\",\"85\":\"18#rdb快照\",\"86\":\"18#执行快照期间-数据能被修改吗\",\"87\":\"18#aof文件可以保存rdb格式吗-rdb-和-aof-合体\",\"88\":\"18#参考链接\",\"89\":\"18@0\",\"90\":\"19\",\"91\":\"19@0\",\"92\":\"20\",\"93\":\"20@0\",\"94\":\"21\",\"95\":\"21@0\",\"96\":\"22\",\"97\":\"22#string\",\"98\":\"22#常用指令\",\"99\":\"22#应用场景\",\"100\":\"22#内部实现\",\"101\":\"22#list\",\"102\":\"22#常用指令-1\",\"103\":\"22#应用场景-1\",\"104\":\"22#内部实现-1\",\"105\":\"22#hash\",\"106\":\"22#常用指令-2\",\"107\":\"22#应用场景-2\",\"108\":\"22#内部实现-2\",\"109\":\"22#set\",\"110\":\"22#常用指令-3\",\"111\":\"22#应用场景-3\",\"112\":\"22#内部实现-3\",\"113\":\"22#zset\",\"114\":\"22#常用指令-4\",\"115\":\"22#应用场景-4\",\"116\":\"22#内部实现-4\",\"117\":\"22#bitmap\",\"118\":\"22#常用指令-5\",\"119\":\"22#应用场景-5\",\"120\":\"22#内部实现-5\",\"121\":\"22#hyperloglog\",\"122\":\"22#常用指令-6\",\"123\":\"22#应用场景-6\",\"124\":\"22#内部实现-6\",\"125\":\"22#geo\",\"126\":\"22#常用指令-7\",\"127\":\"22#应用场景-7\",\"128\":\"22#内部实现-7\",\"129\":\"22#stream\",\"130\":\"22#常用指令-8\",\"131\":\"22#应用场景-8\",\"132\":\"22#内部实现-8\",\"133\":\"22@0\",\"134\":\"23\",\"135\":\"23#redis键值对数据库是如何实现的\",\"136\":\"23#sds\",\"137\":\"23#链表\",\"138\":\"23#压缩列表\",\"139\":\"23#哈希表\",\"140\":\"23#整数集合\",\"141\":\"23#跳表\",\"142\":\"23#quicklist\",\"143\":\"23#listpack\",\"144\":\"23@0\",\"145\":\"24\",\"146\":\"24@0\",\"147\":\"25\",\"148\":\"25#redis默认最大运行内存\",\"149\":\"25#如何配置redis最大运行内存\",\"150\":\"25#redis的内存淘汰策略有哪些\",\"151\":\"25#如何配置redis内存淘汰策略\",\"152\":\"25#lru算法和lfu算法有什么区别\",\"153\":\"25#参考链接\",\"154\":\"25@0\",\"155\":\"26\",\"156\":\"26#如何设置过期时间\",\"157\":\"26#如何判断一个key已经过期\",\"158\":\"26#过期删除策略有哪些\",\"159\":\"26#redis的过期删除策略是什么\",\"160\":\"26#参考链接\",\"161\":\"26@0\",\"162\":\"27\",\"163\":\"27@0\",\"164\":\"28\",\"165\":\"28@0\",\"166\":\"29\",\"167\":\"29#缓存的读写策略\",\"168\":\"29#旁路缓存-cache-aside\",\"169\":\"29#cache-aside-pattern下-数据不一致的情况\",\"170\":\"29#cache-aside-pattern下-删除缓存失败的情况\",\"171\":\"29#读写穿透-write-read-through\",\"172\":\"29#异步缓存写入write-behind-caching-write-back\",\"173\":\"29#如何选择合适的策略\",\"174\":\"29@0\",\"175\":\"30\",\"176\":\"30#缓存雪崩\",\"177\":\"30#雪崩常见原因\",\"178\":\"30#解决方案\",\"179\":\"30#缓存击穿\",\"180\":\"30#击穿常见原因\",\"181\":\"30#解决方案-1\",\"182\":\"30#缓存穿透\",\"183\":\"30#穿透常见原因\",\"184\":\"30#解决方案-2\",\"185\":\"30@0\",\"186\":\"31\",\"187\":\"31@0\",\"188\":\"32\",\"189\":\"32@0\",\"190\":\"33\",\"191\":\"34\",\"192\":\"34@0\",\"193\":\"35\",\"194\":\"35@0\",\"195\":\"36\",\"196\":\"36@0\",\"197\":\"37\",\"198\":\"37@0\",\"199\":\"38\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[null,null,1],\"3\":[1,18],\"4\":[null,null,1],\"5\":[null,null,1],\"6\":[1,20],\"7\":[null,null,1],\"8\":[null,null,1],\"9\":[2,11],\"10\":[2,8],\"11\":[2,13],\"12\":[2,11],\"13\":[2,10],\"14\":[1,10],\"15\":[1,19],\"16\":[1,1],\"17\":[1,3],\"18\":[1,3],\"19\":[1,5],\"20\":[1,2],\"21\":[1,3],\"22\":[1,6],\"23\":[1,2],\"24\":[1],\"25\":[null,null,1],\"26\":[null,null,1],\"27\":[1,3],\"28\":[1,19],\"29\":[1,20],\"30\":[1,12],\"31\":[1,13],\"32\":[null,null,1],\"33\":[null,null,2],\"34\":[1],\"35\":[1],\"36\":[1,1],\"37\":[1,1],\"38\":[1],\"39\":[1],\"40\":[1,1],\"41\":[null,null,1],\"42\":[null,null,1],\"43\":[1],\"44\":[null,null,1],\"45\":[1],\"46\":[1],\"47\":[1],\"48\":[1],\"49\":[1],\"50\":[1],\"51\":[1],\"52\":[1],\"53\":[1],\"54\":[null,null,1],\"55\":[2],\"56\":[1,4],\"57\":[1,1],\"58\":[1,2],\"59\":[2],\"60\":[1,4],\"61\":[1,1],\"62\":[1,2],\"63\":[2],\"64\":[null,null,1],\"65\":[1],\"66\":[1,26],\"67\":[1,27],\"68\":[1,20],\"69\":[1,19],\"70\":[1,17],\"71\":[2,88],\"72\":[1,26],\"73\":[1,7],\"74\":[null,null,1],\"75\":[1],\"76\":[1,51],\"77\":[null,null,1],\"78\":[1],\"79\":[1,52],\"80\":[1,85],\"81\":[1,70],\"82\":[1,17],\"83\":[null,null,1],\"84\":[1],\"85\":[1,48],\"86\":[3],\"87\":[6,28],\"88\":[2,5],\"89\":[null,null,1],\"90\":[2,20],\"91\":[null,null,1],\"92\":[1],\"93\":[null,null,1],\"94\":[2],\"95\":[null,null,1],\"96\":[1,24],\"97\":[1,6],\"98\":[1,2],\"99\":[1],\"100\":[1],\"101\":[1],\"102\":[1,2],\"103\":[1],\"104\":[1],\"105\":[1],\"106\":[1,2],\"107\":[1],\"108\":[1],\"109\":[1],\"110\":[1,2],\"111\":[1],\"112\":[1],\"113\":[1],\"114\":[1,2],\"115\":[1],\"116\":[1],\"117\":[1],\"118\":[1,2],\"119\":[1],\"120\":[1],\"121\":[1],\"122\":[1,2],\"123\":[1],\"124\":[1],\"125\":[1],\"126\":[1,2],\"127\":[1],\"128\":[1],\"129\":[1],\"130\":[1,2],\"131\":[1],\"132\":[1],\"133\":[null,null,1],\"134\":[1],\"135\":[1],\"136\":[1],\"137\":[1],\"138\":[1],\"139\":[1],\"140\":[1],\"141\":[1],\"142\":[1],\"143\":[1],\"144\":[null,null,1],\"145\":[2],\"146\":[null,null,1],\"147\":[1,4],\"148\":[1,17],\"149\":[2,22],\"150\":[2,34],\"151\":[1,22],\"152\":[2,3],\"153\":[2,3],\"154\":[null,null,1],\"155\":[1,4],\"156\":[2,51],\"157\":[2,27],\"158\":[2,50],\"159\":[2,74],\"160\":[2,7],\"161\":[null,null,1],\"162\":[2],\"163\":[null,null,1],\"164\":[1],\"165\":[null,null,1],\"166\":[3,12],\"167\":[1,5],\"168\":[4,22],\"169\":[4],\"170\":[4,17],\"171\":[5,28],\"172\":[6,38],\"173\":[2,6],\"174\":[null,null,1],\"175\":[2,4],\"176\":[1,6],\"177\":[1,12],\"178\":[1,32],\"179\":[1,6],\"180\":[2,6],\"181\":[2,15],\"182\":[1,10],\"183\":[2,10],\"184\":[1,24],\"185\":[null,null,1],\"186\":[2],\"187\":[null,null,1],\"188\":[1],\"189\":[null,null,1],\"190\":[1],\"191\":[2],\"192\":[null,null,1],\"193\":[1],\"194\":[null,null,1],\"195\":[1],\"196\":[null,null,1],\"197\":[1],\"198\":[null,null,1],\"199\":[1,3]},\"averageFieldLength\":[1.317620979986159,13.047102028568112,0.7932709381761754],\"storedFields\":{\"0\":{\"h\":\"首页\"},\"1\":{\"h\":\"主要功能与配置演示\"},\"2\":{\"c\":[\"使用指南\"]},\"3\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"4\":{\"c\":[\"使用指南\"]},\"5\":{\"c\":[\"禁用\"]},\"6\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"7\":{\"c\":[\"指南\"]},\"8\":{\"c\":[\"布局\"]},\"9\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"10\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"11\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"12\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"13\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"14\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"15\":{\"h\":\"提示容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"16\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"17\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"18\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"19\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"20\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注^first.\",\"查看详情\"]},\"21\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"22\":{\"h\":\"任务列表\",\"t\":[\"[x] 计划 1\",\"[ ] 计划 2\",\"查看详情\"]},\"23\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"24\":{\"h\":\"组件\"},\"25\":{\"c\":[\"使用指南\"]},\"26\":{\"c\":[\"Markdown\"]},\"27\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"28\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 --- \"]},\"29\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"30\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"31\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"32\":{\"c\":[\"使用指南\"]},\"33\":{\"c\":[\"页面配置\",\"使用指南\"]},\"34\":{\"h\":\"指南\"},\"35\":{\"h\":\"功能亮点\"},\"36\":{\"h\":\"Bar\",\"t\":[\"...\"]},\"37\":{\"h\":\"Foo\",\"t\":[\"...\"]},\"38\":{\"h\":\"\"},\"39\":{\"h\":\"目录\"},\"40\":{\"h\":\"基础篇\",\"t\":[\"[]\",\"[]\"]},\"41\":{\"c\":[\"python\"]},\"42\":{\"c\":[\"基础\"]},\"43\":{\"h\":\"Mysql学习笔记\"},\"44\":{\"c\":[\"Mysql\"]},\"45\":{\"h\":\"Redis学习笔记\"},\"46\":{\"h\":\"目录\"},\"47\":{\"h\":\"数据结构篇\"},\"48\":{\"h\":\"持久化篇\"},\"49\":{\"h\":\"策略篇\"},\"50\":{\"h\":\"高可用篇\"},\"51\":{\"h\":\"缓存篇\"},\"52\":{\"h\":\"应用篇\"},\"53\":{\"h\":\"面试篇\"},\"54\":{\"c\":[\"Redis\"]},\"55\":{\"h\":\"Bar 功能\"},\"56\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"57\":{\"h\":\"详情\",\"t\":[\"...\"]},\"58\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"59\":{\"h\":\"Foo 功能\"},\"60\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"61\":{\"h\":\"详情\",\"t\":[\"...\"]},\"62\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"63\":{\"h\":\"六、Redis应用篇\"},\"64\":{\"c\":[\"Redis\"]},\"65\":{\"h\":\"Redis分布式锁\"},\"66\":{\"h\":\"锁\",\"t\":[\"锁(lock)是为了解决多个工作流对共享资源的访问出现冲突，锁代表着对公共资源的独占声明，当一个工作流获得锁之后，其他的工作流应当能看到这个资源已经被占用。所以锁的声明和释放一定要基于各个工作流的可见区域来实现。\",\"具体实现方式很多，例如一个进程中的多线程可以利用全局变量在实现；同一个机器的多个进程可以利用共享内存，或者用一个数据库甚至使用一个文件来实现，但是不管怎么实现都要保证如下几点：\",\"互斥性：同一时刻，一个锁只能被一个工作流持有\",\"避免死锁：避免持有锁的工作流因为故障无法释放锁，进而使其他工作流永远都无法获得锁\",\"目前随着分布式处理的广泛使用，我们很多时候需要协调位于不同机器上的不同进程对共享资源的独占使用，这个时候我们就需要在所有机器都能看见的区域来实现锁（分布式锁），同时我们还得应对分布式资源环境下各个机器节点的不可靠性、网络的不稳定性、各个机器时钟的不一致性等问题来努力的保证上述两点锁的性质被满足。\"]},\"67\":{\"h\":\"单节点分布式锁\",\"t\":[\"分布式锁的实现有很多种，本文我们主要讨论Redis的实现方案。\",\"首先让我们来看一下单节点分布式锁的实现：\",\"# 伪代码 def work(lock_name): try: while True: # 此处最好设置一个最大的循环时间，如果超出循环时间则自动结束 if lock(lock_name): # todo pass time.sleep(0.001) finally: unlock(lock_name) def lock(lock_name): return redis.setnx(lock_name) def unlock(lock_name): redis.delete(lock_name) \"]},\"68\":{\"h\":\"给锁加超时时间\",\"t\":[\"以上代码实现中如果当前进程挂了，由于当前进程没有释放锁，那么其他进程将永远不会获得锁出现死锁的情况。所以我们不能单单依赖进程自己去释放锁，应该设置一个超时时间，当锁的时间超过一定时间后自动释放锁。这样如果出现进程挂了，那么过了一定时间后改锁也会自动释放掉。\",\"# 伪代码 def lock(lock_name): if redis.setnx(lock_name): redis.expire(lock_name) return True return False \"]},\"69\":{\"h\":\"使用加参数的set\",\"t\":[\"以上步骤只能解决锁超时自动释放，因为setnx和expire并不是原子性操作，在加锁后进程挂掉依然会出现死锁的问题，我们应该将加锁和设置超时时间做到原子化。在Redis 2.6.12之后的版本可以使用set并设置超时时间和非空判断。\",\"# 伪代码 def lock(lock_name): return redis.set(lock_name, True, ex=30, nx=True) \"]},\"70\":{\"h\":\"给锁添加唯一标识\",\"t\":[\"如果进程A在持有锁的时间内未完成任务，在进程B加锁后进程A才完成任务，此时进程A进行删除锁的操作，那么就会出现进程A删除进程B刚加的锁，出现误删。所以我们在加锁的时间为每一个锁添加一个唯一标识以确保不会出现误删的情况\",\"# 伪代码 def lock(lock_name, identifier): return redis.set(lock_name, identifier, ex=30, nx=True) \"]},\"71\":{\"h\":\"删除锁 原子性操作\",\"t\":[\"在删除锁的时间需要先判断再删除，这两个操作是非原子性的，我们可以通过Lua 脚本来执行判断和删除的操作，因为多条 Lua 命令可以保证原子性，也可以考虑事务实现。\",\"# 伪代码 def release_lock(lock_name, identifier): unlock_script = \\\"\\\"\\\" if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end \\\"\\\"\\\" unlock = redis.register_script(unlock_script) return unlock(keys=[lock_name], args=[identifier]) \",\"至此，基于Redis实现单节点分布式锁基本完成。\",\"最终完成版：\",\"import uuid import math import time def acquire_lock_with_timeout(conn, lock_name, acquire_timeout=3, lock_timeout=2): \\\"\\\"\\\" 基于 Redis 实现的分布式锁 :param conn: Redis 连接 :param lock_name: 锁的名称 :param acquire_timeout: 获取锁的超时时间，默认 3 秒 :param lock_timeout: 锁的超时时间，默认 2 秒 :return: \\\"\\\"\\\" identifier = str(uuid.uuid4()) lockname = f'lock:{lock_name}' lock_timeout = int(math.ceil(lock_timeout)) end = time.time() + acquire_timeout while time.time() < end: # 如果不存在这个锁则加锁并设置过期时间，避免死锁 if conn.set(lockname, identifier, ex=lock_timeout, nx=True): return identifier time.sleep(0.001) return False def release_lock(conn, lock_name, identifier): \\\"\\\"\\\" 释放锁 :param conn: Redis 连接 :param lockname: 锁的名称 :param identifier: 锁的标识 :return: \\\"\\\"\\\" unlock_script = \\\"\\\"\\\" if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end \\\"\\\"\\\" lockname = f'lock:{lock_name}' unlock = conn.register_script(unlock_script) result = unlock(keys=[lockname], args=[identifier]) if result: return True else: return False \",\"如果依赖单节点，我们就要承受单节点带来的风险，我们能不能多启动几个Redis，保留键的副本，这样如果一个节点挂掉其他节点能继续工作呢？如果锁超时了我们如何给锁续期以及如何避免锁的无限续期。下面我们将试着讨论Redlock。\"]},\"72\":{\"h\":\"Redlock\",\"t\":[\"redlock的核心思想就是使用多个Redis冗余实例来避免单Redis的不可靠性。如果使用多个Redis，我们就要考虑读写的一致性问题，Redlock采用的是法团准则方案，即写入(N/2 +1)个节点后才成功，获得至少(N/2 +1)个服务器的锁则认为获得锁成功。\",\"假设我们有五台机器，如果进程1从R1、R2、R3机器获得了锁，然后R1机器未将数据持久化到磁盘出现宕机，之后再次重启，此时进程2可以从R1、R4、R5重新获得锁（满足法团准则），这样就会出现冲突。为了解决这个问题Redis作者提出了延迟重启的解决方案。\",\"延迟重启\",\"我们可以发现受R1挂了重启影响的只有在R1挂了的时刻在R1上存到锁，之后的创建的或者没在R1上存储的锁都不会受到影响\"]},\"73\":{\"h\":\"Watchdog的设计原则\",\"t\":[\"参考链接：\",\"基于Redis的分布式锁详解\",\"基于Redis的分布式锁设计\",\"Python 使用 Redis 实现分布式锁\"]},\"74\":{\"c\":[\"Redis\"]},\"75\":{\"h\":\"布隆过滤器与布谷鸟过滤器\"},\"76\":{\"h\":\"布隆过滤器\",\"t\":[\"原理：\",\"查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。\",\"实例代码：\",\"from pybloom_live import BloomFilter # 初始化布隆过滤器 bloom = BloomFilter(capacity=100000, error_rate=0.001) # 在数据写入数据库时更新布隆过滤器 def add_to_bloom_filter(key): bloom.add(key) # 查询时使用布隆过滤器 def get_data(key): if key not in bloom: return None value = redis_client.get(key) if value is None: value = fetch_data_from_db(key) if value is None: redis_client.setex(key, 60, \\\"NULL\\\") else: redis_client.setex(key, 3600, value) elif value == \\\"NULL\\\": return None return value \",\"参考链接：\",\"布隆，牛逼！布谷鸟，牛逼！\",\"python-布隆过滤器\"]},\"77\":{\"c\":[\"Redis\"]},\"78\":{\"h\":\"AOF持久化\"},\"79\":{\"h\":\"AOF日志\",\"t\":[\"如果每执行一个写操作命令，就把该命令追加写入到一个文件，在重启Redis的时候读取文件中的命令并去执行它，就相当于恢复缓存数据了。这种保存写操作命令到日志的持久化方式就是AOF（Append Only File）持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的，因为记录读操作没有意义。\",\"如何配置AOF持久化\",\"AOF持久化功能默认是不开启的，需要我们去修改redis.conf配置文件中的appendonly参数去开启AOF持久化（默认该参数为 no，即不开启），appendfilename参数去指定AOF持久化文件的名称（默认为 appendonly.aof）。\",\"AOF日志文件内容\",\"AOF日志文件其实就是普通文本，可以通过cat命令查看里面的内容，例如我们执行set key1 value1命令，AOF文件中则会写下如下内容：\",\"*3 $3 set $4 key1 $6 value1 \",\"上诉内容中，「*3」代表当前命令有三个部分，每个部分都是以「$+数字」开头，后面跟具体命令、键或值。这里的「数字」表示这部分命令、键或值一共有多少字节，例如「$3 set」表示这部分有3个字节，也就是「set」命令这个字符串的长度。\"]},\"80\":{\"h\":\"AOF写回策略\",\"t\":[\"Redis是先执行命令再将该命令写入到AOF文件中，这样做其实有两个好处：\",\"避免额外的检查开销，只有执行成功后才将命令记录到AOF日志里，不用在写入前检查命令语法是否正确，保证每条写入AOF日志里的命令都是可执行且正确的。\",\"不会阻塞当前写操作命令的执行，因为只有写操作执行成功后才会将命令记录到AOF日志。\",\"当然，由于执行写操作命令和记录日志是两个过程，所以AOF持久化功能也存在一定的风险。\",\"当命令执行成功但是还没来得及写入到硬盘的时候，服务器发生了宕机，这个数据就会发生丢失。\",\"虽然写操作命令执行成功后才会记录到AOF日志，不会阻塞当前命令的执行，但是会给「下一个」命令带来阻塞风险。因为将命令写入到日志的操作也是在主进程进行的，也就是说这两个操作是同步的，如果将日志写入到磁盘时，服务器的硬盘I/O压力太大，就会导致写硬盘的速度很慢，进而发生阻塞导致后续命令无法执行。\",\"认真分析可以发现两个风险都有一个共性，就是都跟AOF日志写回硬盘的时机有关。Redis写入AOF日志的过程大体如下：\",\"1、Redis执行完写操作命令后，将命令追加到server.aof_buf缓冲区；\",\"2、然后通过write()系统命令调用将aof_buf缓冲区到数据写入到AOF文件，此时数据并未写入到硬盘，而是拷贝到了内核缓冲区page cache，等待内核将数据写入到硬盘；\",\"3、具体内核缓冲区的数据什么时候写入到硬盘，由内核决定；\",\"Redis提供了3种写回硬盘的策略，控制的就是上面说的第三步的过程：\",\"Always：每次执行完命令，同步将AOF日志数据写回到硬盘；最大程度保证数据不丢失，但是由于频繁落盘不可避免的影响主进程性能。\",\"Everysec：每次执行完命令，先将命令写入到AOF文件到内核缓冲区，然后每隔一秒再将缓冲区内容写回到硬盘；折中的方案，避免了Always的性能开销，也比No策略更能避免数据丢失，发生宕机时丢失一秒内的数据。\",\"No：每次执行完命令，先将命令写入到AOF文件到内核缓冲区，由操作系统决定何时将缓冲区内容写回硬盘；相比较Always性能较好，但是操作系统何时落盘是不可预知的，一旦服务器宕机就会丢失不定数量的数据。\",\"写回策略\",\"写回时机\",\"优点\",\"缺点\",\"Always\",\"同步写回\",\"最大程度保证数据不丢失\",\"每个写命令都要写回硬盘，性能开销大\",\"Everysec\",\"每秒写回\",\"性能适中\",\"机器宕机会丢失1秒内的数据\",\"No\",\"由操作系统控制写回\",\"性能好\",\"机器宕机可能会丢失很多数据\",\"如何配置Redis写回策略\",\"修改redis.coonf配置文件中的appendfsync配置项，该配置项默认为everysec，即每秒将写入操作同步到磁盘一次。这种设置在一定程度上平衡了数据的持久性和性能之间的关系，提供了一定的数据安全性保障同时在一定程度上减少了磁盘同步操作对性能的影响。\"]},\"81\":{\"h\":\"AOF重写机制\",\"t\":[\"随着写操作命令越来越多，AOF日志文件越来越大。AOF日志文件过大时就会带来性能问题，如重启Redis后需要读AOF文件的内容以恢复数据，如果文件过大，整个恢复过程就会很慢。Redis为避免这种情况提供了AOF重写，当AOF文件大小超过所设定的阈值后（AOF 重写的默认触发条件是当 AOF 文件大小超过 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 两个配置参数所设定的阈值时。），Redis就会启动重写机制来压缩AOF文件。\",\"auto-aof-rewrite-percentage 的值默认为 100，表示当当前 AOF 文件的大小达到上一次重写后的大小的 100%（即翻倍）时，Redis 将会尝试执行 AOF 重写操作。\",\"auto-aof-rewrite-min-size 的值默认为 64MB。这意味着当 AOF 文件的大小超过 64MB 时，Redis 将尝试执行 AOF 重写操作。\",\"AOF重写机制是在重写时，读取当前数据库中所有的键值对，然后将每一个键值对记录到「新的AOF文件中」，等到全部记录完后，就将新的AOF文件替换掉现有的AOF文件。例如在没执行重写机制前前后执行了「set key1 value1」和「set key1 value2」这两个命令的话，就会将这两个命令都写入到AOF文件，但是在使用重写机制后，就会读取最新的key-value键值对，然后用一条「set key1 value2」命令记录到新的AOF文件中，之前的「set key1 value1」就属于历史命令，没有必要记录了，这样一来一个键值对在重写日志中只用一条命令就可以了。\",\"重写完成后会使用新的AOF文件替换现有的AOF文件，使得AOF文件变小。重写机制的作用就是尽管某个键值对被多条命令反复修改了多次，最终也只需要根据这个键值对当前最新状态，用一条命令去记录最新键值对，代替之前记录的多条命令，这样就减少了AOF文件中命令的数量。最后在完成工作后用最新的AOF文件覆盖现有的AOF文件。\",\"重写过程是先写到新的AOF文件，然后再覆盖过去，避免了AOF在重写过程中发生失败造成现有的AOF文件污染，如果重写失败，直接删除这个文件就好了，不会对现有的AOF文件造成影响。\"]},\"82\":{\"h\":\"AOF后台重写\",\"t\":[\"重写是由后台子进程完成的。使用后台子进程原因：\",\"不阻塞主进程处理命令\",\"子线程会共享内存，在发生变更操作时需要加锁，降低执行效率。子进程以只读的方式共享内存，如果发生变更就会产生写时复制，不用再通过加锁来保证数据安全。\",\"在重写期间主进程仍可执行命令，此时会维护一个AOF 重写缓冲区，在执行AOF重写期间，主进程需要执行以下三步\",\"执行客户端发来的命令\",\"行命令追加到AOF缓存区\",\"执行命令追加到AOF重写缓冲区\"]},\"83\":{\"c\":[\"Redis\"]},\"84\":{\"h\":\"RDB持久化\"},\"85\":{\"h\":\"RDB快照\",\"t\":[\"RDB快照是什么\",\"RDB快照是记录某一瞬间的内存数据，记录的是实际数据（二进制数据），而AOF文件记录的是命令的操作日志（操作日志），而不是实际数据。因此在Redis恢复数据时，RDB恢复数据的效率会比AOF高，因为RDB是直接将二进制文件读入内存就可以了，不需要像AOF那样还需要额外执行操作命令的步骤才能恢复数据。\",\"RDB快照如何使用\",\"Redis提供了两个命令来生成RDB文件，分别是save和bgsave，他们的区别就是是否在「主线程」里执行：\",\"执行了save命令，就会在主线程生成RDB文件，由于和执行命令在同一个线程，所以如果写入RDB文件的时间过久，会阻塞主线程；\",\"执行了bgsave命令，会创建一个子进程来生成RDB文件，这样可以避免主线程阻塞；\",\"RDB文件加载是在服务器启动时自动执行，Redis并未提供专门用于加载RDB文件的命令。\",\"Redis还可以通过修改配置文件选项来实现每隔一段时间自动执行一次bgsave命令，默认配置如下：\",\"save 900 1 # 900秒内，对数据库进行了至少1次修改就会执行bgsave； save 300 10 # 300秒内，对数据库进行了至少10次修改就会执行bgsave； save 60 10000 # 60秒内对数据库进行了至少10000次修改就会执行bgsave； \",\"Redis的快照是全量快照，每次执行时都会把内存中的所有数据记录到磁盘。所以可以认为执行快照是一个比较重的操作，如果执行太频繁可能对Redis性能产生影响，如果频率太低，服务器故障时又会丢失很多数据。\"]},\"86\":{\"h\":\"执行快照期间，数据能被修改吗？\"},\"87\":{\"h\":\"AOF文件可以保存RDB格式吗?(RDB 和 AOF 合体)\",\"t\":[\"RDB持久化与AOF持久化的优缺点\",\"AOF持久化机器宕机时丢失数据少，但是重启Redis时恢复数据较慢\",\"RDB持久化重启Redis时恢复数据较快，但是机器宕机时丢失数据较多\",\"混合持久化\",\"在Redis4.0版本之后，提出了混合使用AOF日志和RDB快照，该方法又叫混合持久化。\",\"混合持久化工作在AOF日志重写的过程。当开启了混合持久化时，fork出来的重写子进程会先将与主进程共享的内存数据以RDB方式写入到AOF文件。Redis 后台子进程重写 AOF 期间，主线程处理的操作命令都会被记录在重写缓冲区，重写缓冲区里的增量命令会以AOF方式写入到AOF文件，写入完成后通知主进程将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。\",\"也就是说使用了混合持久化的AOF文件前半部分说RDB格式的全量数据，后半部分是AOF格式的增量数据。这样在Redis重启加载数据的时候，由于前半部分是RDB格式的，这样加快加载速度，加载完RDB的内容后在加载后半部部分的AOF内容，这样减少数据丢失。\"]},\"88\":{\"h\":\"参考链接：\",\"t\":[\"AOF 文件可以保存 RDB 格式吗\",\"Redis中的缓冲区了解吗\"]},\"89\":{\"c\":[\"Redis\"]},\"90\":{\"h\":\"二、Redis持久化篇\",\"t\":[\"Redis是基于内存进行读写操作的，在重启后数据就会丢失，为了保证数据不丢失，Redis实现了持久化机制，使用这个机制将数据存储到磁盘上，这样在Redis重启到时候就能从磁盘上恢复数据。支持三种持久化方式：\",\"AOF日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里（记录的是操作命令）；\",\"RDB快照：将某一时刻的数据，以二进制的方式写入磁盘（记录的是二进制数据）；\",\"混合持久化存储：Redis4.0版本新增的方式，集成了AOF和RDB的优点；\"]},\"91\":{\"c\":[\"Redis\"]},\"92\":{\"h\":\"大Key对持久化的影响\"},\"93\":{\"c\":[\"Redis\"]},\"94\":{\"h\":\"一、Redis数据类型篇\"},\"95\":{\"c\":[\"Redis\"]},\"96\":{\"h\":\"Redis数据类型及应用场景\",\"t\":[\"五种常见的数据结构：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。\",\"随着版本更新，后面又支持了四种数据结构：BitMap（2.2版新增）、HyperLogLog（2.8版新增）、GEO（3.2版新增）、Stream（5.0版新增）。\"]},\"97\":{\"h\":\"String\",\"t\":[\"String是最基本的key-value结构，key是唯一的标识，value是具体的值，value最多可容纳的数据长度为512M。\"]},\"98\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"99\":{\"h\":\"应用场景\"},\"100\":{\"h\":\"内部实现\"},\"101\":{\"h\":\"List\"},\"102\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"103\":{\"h\":\"应用场景\"},\"104\":{\"h\":\"内部实现\"},\"105\":{\"h\":\"Hash\"},\"106\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"107\":{\"h\":\"应用场景\"},\"108\":{\"h\":\"内部实现\"},\"109\":{\"h\":\"Set\"},\"110\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"111\":{\"h\":\"应用场景\"},\"112\":{\"h\":\"内部实现\"},\"113\":{\"h\":\"Zset\"},\"114\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"115\":{\"h\":\"应用场景\"},\"116\":{\"h\":\"内部实现\"},\"117\":{\"h\":\"BitMap\"},\"118\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"119\":{\"h\":\"应用场景\"},\"120\":{\"h\":\"内部实现\"},\"121\":{\"h\":\"HyperLogLog\"},\"122\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"123\":{\"h\":\"应用场景\"},\"124\":{\"h\":\"内部实现\"},\"125\":{\"h\":\"GEO\"},\"126\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"127\":{\"h\":\"应用场景\"},\"128\":{\"h\":\"内部实现\"},\"129\":{\"h\":\"Stream\"},\"130\":{\"h\":\"常用指令\",\"t\":[\"基本操作：\"]},\"131\":{\"h\":\"应用场景\"},\"132\":{\"h\":\"内部实现\"},\"133\":{\"c\":[\"Redis\"]},\"134\":{\"h\":\"Redis数据结构\"},\"135\":{\"h\":\"Redis键值对数据库是如何实现的\"},\"136\":{\"h\":\"SDS\"},\"137\":{\"h\":\"链表\"},\"138\":{\"h\":\"压缩列表\"},\"139\":{\"h\":\"哈希表\"},\"140\":{\"h\":\"整数集合\"},\"141\":{\"h\":\"跳表\"},\"142\":{\"h\":\"quicklist\"},\"143\":{\"h\":\"listpack\"},\"144\":{\"c\":[\"Redis\"]},\"145\":{\"h\":\"三、Redis策略篇\"},\"146\":{\"c\":[\"Redis\"]},\"147\":{\"h\":\"Redis内存淘汰策略\",\"t\":[\"当Redis的运行内存已经超过Redis设置的最大内存之后，会使用内存淘汰策略淘汰符合条件的key，以此来保障Redis高效的运行。\"]},\"148\":{\"h\":\"Redis默认最大运行内存\",\"t\":[\"只有在Redis的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，maxmemory的默认值是不同的：\",\"在64位操作系统中，maxmemory的默认值是0，表示没有内存大小限制，那么不管用户存放多少数据刀Redis中，Redis也不会对可用内存进行检查，知道Redis实例因内存不足崩溃也不做任何操作。\",\"在32位操作系统中，maxmemory的默认值是3G，因为32位的机器最大只支持4GB的内存，而系统本身又需要一定的内存资源来支持运行，所以32位操作系统限制最大3GB的可用内存是非常合理的，这样可以避免内存不足而导致的Redis实例崩溃。\"]},\"149\":{\"h\":\"如何配置Redis最大运行内存？\",\"t\":[\"可以通过以下两种方式配置最大运行内存：\",\"通过 config set maxmemory 1GB 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。\",\"在配置文件redis.conf中可以通过参数maxmemory <bytes>来设定最大的运行内存，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。\"]},\"150\":{\"h\":\"Redis的内存淘汰策略有哪些？\",\"t\":[\"Redis内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略，可以通过config get maxmemory-policy查看当前内存淘汰策略。\",\"noeviction：默认策略，运行内存达到最大设置内存时不淘汰任何数据，如果此时有新数据写入会报错，但是如果没新数据写入，单纯查询或者删除依然可以正常工作。\",\"volatile-random：随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"volatile-ttl：根据键值对象的ttl属性，优先淘汰更早过期的键值。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"volatile-lru：根据LRU算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"volatile-lfu：根据LFU算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"allkeys-random：随机删除所有键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"allkeys-lru：根据LRU算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\",\"allkeys-lfu：根据LFU算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。\"]},\"151\":{\"h\":\"如何配置Redis内存淘汰策略\",\"t\":[\"通过 config set maxmemory-policy <策略> 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。\",\"通过修改 Redis 配置文件修改，设置 maxmemory-policy <策略>，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。\"]},\"152\":{\"h\":\"LRU算法和LFU算法有什么区别？\",\"t\":[\"LRU算法\",\"LFU算法\",\"Redis如何管理热数据\"]},\"153\":{\"h\":\"参考链接：\",\"t\":[\"Redis过期删除策略\",\"内存耗尽后Redis会发生什么？\"]},\"154\":{\"c\":[\"Redis\"]},\"155\":{\"h\":\"Redis过期删除策略\",\"t\":[\"Redis是可以对key设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值对删除策略。\"]},\"156\":{\"h\":\"如何设置过期时间？\",\"t\":[\"设置key过期时间，共有4种命令：\",\"expire <key> <seconds>：设置key在seconds后过期，比如expire key 100表示设置key在100秒之后过期。\",\"pexpire <key> <milliseconds>：设置key在milliseconds后过期，比如pexpire key 100表示设置key在100毫秒后过期。\",\"expireat <key> <timestamp>：设置key在某个时间戳（精确到秒）之后过期，比如expireat key 1704038400表示设置key在时间戳1704038400（精确到秒）后过期。\",\"expireat <key> <timestamp>：设置key在某个时间戳（精确到毫秒）之后过期，比如pexpireat key 1704038400000表示设置key在时间1704038400000（精确到毫秒）后过期。\",\"当然在设置字符串时也可以同时对key设置过期时间，共有三种命令：\",\"set <key> <value> ex <seconds>：设置key时同时设置多少秒后过期。\",\"set <key> <value> px <milliseconds>：设置key时同时设置多少毫秒后过期。\",\"setex <key> <ttl> <value>：设置key时同时设置多少秒后过期，等同于set <key> <value> ex <seconds>。\",\"如果想查看某个key对过期时间，有两种命令（如果返回-2则表示key不存在，如果返回-1则表示永不超时）：\",\"ttl <key>：返回key过期还剩多少秒。\",\"pttl <key>：返回key过期还剩多少毫秒。\",\"当然，如果突然反悔，取消key的过期时间，则可以使用：\",\"persist <key>：取消key的过期时间。\"]},\"157\":{\"h\":\"如何判断一个KEY已经过期？\",\"t\":[\"当我们对一个key设置过期时间时，Redis会把该key带上过期时间存储到一个过期字典中，也就是说「过期字典」保存了数据库中所有key的过期时间。\",\"typedef struct redisDb { dict *dict; //所有的键值对 dict *expires; //设置了过期时间的键值对 //... 省略了其他属性 } redisDb; \",\"redisDb\",\"过期字典实际上是一个哈希表，哈希表最大的好处就是让我们可以用O(1)的时间复杂度来快速查找，当我们查找一个key时，Redis首先会检查该key是否存在于过期字典中：\",\"如果不存在，则正常读取键值；\",\"如果存在，则会获取该key的过期时间，然后与当前系统时间比对，如果比系统时间大则证明未过期，反之则证明该key已过期；\"]},\"158\":{\"h\":\"过期删除策略有哪些？\",\"t\":[\"如果将一个过期的key删除，我们一般有三种策略：\",\"定时删除\",\"在设置KEY的过期时间时同时创建一个定时事件，当时间到达时，由事件处理器自动执行key的删除操作。\",\"优点：可以保证过期key会被尽快删除，也就是内存尽快释放。因此，定时删除策略对内存友好。\",\"缺点：在过期key较多的情况下，删除过期KEY会占用相当一部分CPU时间，在内存不紧张但CPU紧张的情况下，将CPU用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对CPU不友好。\",\"惰性删除\",\"不主动删除key，每次从数据库访问key时，都检测key是否过期，如果过期则删除该key。\",\"优点：因为只有访问时才会检测key是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对CPU友好。\",\"缺点：如果一个key已经过期，但是这个key一直没有被访问到，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。\",\"定期扫描\",\"每隔一段时间「随机」从数据库中取出一定数量的key进行检查，并删除其中过期的key。\",\"优点： \",\"通过限制执行时长和执行频率来减少删除操作对CPU对影响。\",\"同时也能删除一部分过期数据，减少了过期键对空间的无效占用。\",\"缺点： \",\"难以确定删除执行时长和频率，内存清理方面没定时删除效果好，使用资源方面没有惰性删除使用的少。\",\"如果执行太频繁，定期删除策略会变的和定时删除策略一样，对CPU不友好。\",\"如果执行太少，又会和惰性删除一样，过期key得不到及时释放。\"]},\"159\":{\"h\":\"Redis的过期删除策略是什么？\",\"t\":[\"Redis选择「惰性删除」+「定期扫描」这两种策略配合使用，以求合理使用CPU时间和避免内存浪费之间取得平衡。\",\"Redis是如何实现惰性删除的\",\"Redis在访问或者修改key之前都会调用expireIfNeeded函数对其进行检查，检查key是否过期：\",\"如果过期则删除该key，至于是异步删除还是同步删除，根据 lazyfree_lazy_expire 参数配置决定（Redis 4.0版本之后开始提供参数），然后返回null给客户端；\",\"如果没有过期，不做任何处理，正常返回键值给客户端；\",\"Redis是如何实现定时删除的\",\"在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是10。\",\"从过期字典中随机抽取 20 个 key；\",\"检查这 20 个 key 是否过期，并删除已过期的 key；\",\"如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。\",\"Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。\",\"值得说明的是，由于随机选择的特性，可能存在一些过期的key长时间未被删除掉，为了避免这种情况，在Redis6.0及之后的版本，已经改成了顺序遍历字典表的方式，同时会记录下标。\"]},\"160\":{\"h\":\"参考链接：\",\"t\":[\"Redis过期删除策略\",\"Redis 过期删除策略、惰性删除（lazy-free），深入剖析\"]},\"161\":{\"c\":[\"Redis\"]},\"162\":{\"h\":\"五、Redis缓存篇\"},\"163\":{\"c\":[\"Redis\"]},\"164\":{\"h\":\"数据库与缓存一致性\"},\"165\":{\"c\":[\"Redis\"]},\"166\":{\"h\":\"缓存类型有哪些？经典的缓存策略有哪些？\",\"t\":[\"缓存（Cache）是一种高效的数据存储技术，旨在提高数据访问速度。\",\"它将频繁访问或最近使用的数据临时存储在更快速但较小的存储介质（如内存）中，以减少从较慢的存储设备（如硬盘或远程服务器）读取数据的次数。以下是一些关于缓存的关键点：\"]},\"167\":{\"h\":\"缓存的读写策略\",\"t\":[\"选择缓存的读写策略是缓存设计中的关键步骤，他直接影响系统的性能、数据一致性和可用性。以下是几种常见的缓存读写策略及其适用场景：\"]},\"168\":{\"h\":\"旁路缓存（Cache Aside）\",\"t\":[\"Cache Aside\",\"1、读（Cache Read-Aside）\",\"应用程序首先检查缓存以获取所需数据。如果缓存中存在数据，则直接返回给应用程序。\",\"如果缓存未命中，应用程序将从数据源（例如数据库）中读取数据，并手动将数据放入缓存中，以便下次访问时直接从缓存中获取。\",\"2、写（Cache Write-Aside）\",\"更新数据时，应用程序首先将数据写入数据库。\",\"然后应用程序使缓存中的相关数据失效（即删除缓存中的数据）。\"]},\"169\":{\"h\":\"Cache Aside pattern下，数据不一致的情况\"},\"170\":{\"h\":\"Cache Aside pattern下，删除缓存失败的情况\",\"t\":[\"Cache-Aside pattern 模式 是先更新数据库，再删除缓存。在删除缓存时，有可能删除失败，导致缓存中的数据是旧的。 在此模式下，要确保删除操作最终要被执行，这样才可以保证数据的最终一致性。以下是一些处理方式:\",\"重试机制\",\"延迟双删\",\"异步任务\",\"订阅binlog+异步任务\"]},\"171\":{\"h\":\"读写穿透（Write/Read Through）\",\"t\":[\"Write/Read Through\",\"1、读（Read Through）\",\"应用程序直接访问缓存，如果缓存中存在数据，则直接返回给应用程序。\",\"如果缓存未命中，缓存系统负责从数据源中读取数据，然后将数据写入缓存，并返回给应用程序。\",\"Cache-Aside 策略与Read-Through 策略的区别：Cache-Aside 策略需要应用程序负责数据加载到缓存的过程，而 Read-Through 策略则将这一过程交给缓存系统处理。\",\"2、写（Write Through）\",\"应用程序尝试写入数据到缓存。\",\"如果缓存中存在相应数据，则数据将被写入缓存，并同步更新数据库。\",\"如果缓存未命中，即缓存中不存在需要写入的数据，则应用程序负责将数据写入数据库。\"]},\"172\":{\"h\":\"异步缓存写入Write-Behind Caching (Write-Back)\",\"t\":[\"1、读\",\"当应用程序需要读取数据时，首先会检查缓存。\",\"如果数据在缓存中存在且是最新的，则直接从缓存中获取数据并返回给应用程序。\",\"如果数据在缓存中是“脏数据”或不存在，缓存系统会从持久存储中获取最新的数据，并更新缓存中的数据，然后返回给应用程序。\",\"2、写\",\"应用程序尝试写入数据到缓存。\",\"如果缓存中存在相应数据，则数据将被写入缓存，同时将缓存数据设置为脏的，然后立马返回。\",\"缓存系统会根据一定的策略（如时间间隔、数据量、缓存空间等）来批量异步更新的方式将“脏数据”写回到持久存储中。即有一定的延迟性，这个策略通常由系统管理员根据应用需求进行配置。\",\"异步缓存写入和读写穿透很相似，两者都是由cache服务来负责cache和DB的读写。\",\"两者最大的不同点就是：读写穿透是同步更新DB和cache，而异步缓存写入则是只更新cache，不直接更新DB，而是改为异步批量的方式更新DB。InnoDB Buffer Pool机制就是采用这种模式。\"]},\"173\":{\"h\":\"如何选择合适的策略？\",\"t\":[\"参考链接：\",\"Redis 双写一致性\",\"数据库和缓存如何保证一致性｜小林 coding\",\"3种常用的缓存读写策略详解\"]},\"174\":{\"c\":[\"Redis\"]},\"175\":{\"h\":\"缓存雪崩、缓存击穿与缓存穿透\",\"t\":[\"在Redis使用过程中，可能会遇到各种问题。以下是一些常见问题及解决方案：\"]},\"176\":{\"h\":\"缓存雪崩\",\"t\":[\"问题描述：指缓存中大量数据在同一时间突然失效或者突然不可用时，大量的请求直接打到后端数据库，导致数据库压力剧增，甚至崩溃的现象。\"]},\"177\":{\"h\":\"雪崩常见原因\",\"t\":[\"大量热点数据失效：热门数据在缓存中失效，会导致大量请求直接打到数据库，数据库压力骤增。\",\"缓存集中过期：如果大量缓存数据设置了相同或接近的过期时间，当这些缓存同时过期时，大量请求会同时打到后端数据库。\",\"缓存服务器宕机：当缓存服务器宕机或不可用时，所有请求都会直接打到后端数据库。\"]},\"178\":{\"h\":\"解决方案\",\"t\":[\"热点数据用不过期：对一些非常热点的数据，设置永不过期，并在后台定时刷新这些数据。\",\"随机化过期时间：设置缓存数据的过期时间时，加入一定的随机性，避免大量缓存数据在同一时间过期。\",\"搭建高可用集群：部署 Redis 高可用架构，如主从复制、哨兵（Sentinel）、集群模式等，以确保即使部分节点宕机，整个系统依然可用。\",\"缓存预热：在系统启动时或低峰期，可以通过缓存预热的方式将热点数据提前加载到缓存中，减少在高峰期对数据库的请求压力。\",\"互斥锁：在缓存失效时，通过加锁机制来控制只有一个线程去加载数据和更新缓存，其他线程等待锁释放后再访问缓存。\",\"限流降级：在缓存失效的情况下，使用限流机制保护数据库，或者降级处理，返回默认值或提示用户稍后重试。\"]},\"179\":{\"h\":\"缓存击穿\",\"t\":[\"问题描述：缓存中的某个热点数据在失效的瞬间，有大量请求并发访问该数据，直接打到了后端数据库，造成数据库压力骤增。\"]},\"180\":{\"h\":\"击穿常见原因：\",\"t\":[\"某个热点数据失效：某个热点数据的访问频率非常高，如果这个数据突然失效，可能会引起大量请求同时访问该数据，导致缓存击穿。\"]},\"181\":{\"h\":\"解决方案：\",\"t\":[\"可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。应对缓存击穿可采取前面说到的两种方案\",\"热点数据用不过期：对一些非常热点的数据，设置永不过期，并在后台定时刷新这些数据。\",\"互斥锁：单机可设置互斥锁，分布式的话还得使用。保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\"]},\"182\":{\"h\":\"缓存穿透\",\"t\":[\"问题描述：查询的数据既不在缓存也不在数据库，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据来服务后续的请求。那么当有大量这样的请求到来时，造成数据库压力骤增。\"]},\"183\":{\"h\":\"穿透常见原因：\",\"t\":[\"业务误操作：缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据。\",\"恶意攻击：被攻击，恶意访问某些不存在数据的业务，例如数据库的ID一般都是从1自增上去的，而用户不断访问ID为-1的数据或者ID特别大不存在的数据。\"]},\"184\":{\"h\":\"解决方案\",\"t\":[\"参数校验：对请求的参数进行合理性校验，防止恶意请求进入系统。\",\"缓存空值：对于查询数据库后确认不存在的数据，将空结果（如null或特定的占位符）缓存起来，设置一个短暂的过期时间（时间过久可能会影响业务），以避免频繁查询同一个不存在的数据。\",\"限流：对IP进行限流，普通用户不会单秒内发起大量的请求。\",\"：使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；\",\"参考链接：\",\"雪崩、击穿\",\"什么是缓存雪崩、击穿、穿透？ | 小林 coding\"]},\"185\":{\"c\":[\"Redis\"]},\"186\":{\"h\":\"七、Redis面试篇\"},\"187\":{\"c\":[\"Redis\"]},\"188\":{\"h\":\"Redis常见面试题\"},\"189\":{\"c\":[\"Redis\"]},\"190\":{\"h\":\"Redis中的缓冲区了解吗\"},\"191\":{\"h\":\"四、Redis高可用篇\"},\"192\":{\"c\":[\"Redis\"]},\"193\":{\"h\":\"主从模式\"},\"194\":{\"c\":[\"Redis\"]},\"195\":{\"h\":\"哨兵模式\"},\"196\":{\"c\":[\"Redis\"]},\"197\":{\"h\":\"集群模式\"},\"198\":{\"c\":[\"Redis\"]},\"199\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"四\",{\"0\":{\"191\":1}}],[\"七\",{\"0\":{\"186\":1}}],[\"小林\",{\"1\":{\"184\":1}}],[\"|\",{\"1\":{\"184\":1}}],[\"穿透\",{\"1\":{\"184\":1}}],[\"穿透常见原因\",{\"0\":{\"183\":1}}],[\"什么是缓存雪崩\",{\"1\":{\"184\":1}}],[\"击穿\",{\"1\":{\"184\":2}}],[\"击穿常见原因\",{\"0\":{\"180\":1}}],[\"雪崩\",{\"1\":{\"184\":1}}],[\"雪崩常见原因\",{\"0\":{\"177\":1}}],[\"普通用户不会单秒内发起大量的请求\",{\"1\":{\"184\":1}}],[\"限流\",{\"1\":{\"184\":1}}],[\"限流降级\",{\"1\":{\"178\":1}}],[\"防止恶意请求进入系统\",{\"1\":{\"184\":1}}],[\"恶意访问某些不存在数据的业务\",{\"1\":{\"183\":1}}],[\"恶意攻击\",{\"1\":{\"183\":1}}],[\"被攻击\",{\"1\":{\"183\":1}}],[\"业务误操作\",{\"1\":{\"183\":1}}],[\"没办法构建缓存数据来服务后续的请求\",{\"1\":{\"182\":1}}],[\"没有必要记录了\",{\"1\":{\"81\":1}}],[\"再去访问数据库时\",{\"1\":{\"182\":1}}],[\"再删除缓存\",{\"1\":{\"170\":1}}],[\"发现数据库中也没有要访问的数据\",{\"1\":{\"182\":1}}],[\"发现缓存缺失\",{\"1\":{\"182\":1}}],[\"发生宕机时丢失一秒内的数据\",{\"1\":{\"80\":1}}],[\"要么就返回空值或者默认值\",{\"1\":{\"181\":1}}],[\"要么等待锁释放后重新读取缓存\",{\"1\":{\"181\":1}}],[\"要确保删除操作最终要被执行\",{\"1\":{\"170\":1}}],[\"未能获取互斥锁的请求\",{\"1\":{\"181\":1}}],[\"某个热点数据的访问频率非常高\",{\"1\":{\"180\":1}}],[\"某个热点数据失效\",{\"1\":{\"180\":1}}],[\"造成数据库压力骤增\",{\"1\":{\"179\":1,\"182\":1}}],[\"造成了一定的内存空间浪费\",{\"1\":{\"158\":1}}],[\"其他线程等待锁释放后再访问缓存\",{\"1\":{\"178\":1}}],[\"其他的工作流应当能看到这个资源已经被占用\",{\"1\":{\"66\":1}}],[\"互斥锁\",{\"1\":{\"178\":1,\"181\":1}}],[\"互斥性\",{\"1\":{\"66\":1}}],[\"减少在高峰期对数据库的请求压力\",{\"1\":{\"178\":1}}],[\"减少了过期键对空间的无效占用\",{\"1\":{\"158\":1}}],[\"哨兵模式\",{\"0\":{\"195\":1}}],[\"哨兵\",{\"1\":{\"178\":1}}],[\"高可用架构\",{\"1\":{\"178\":1}}],[\"高可用篇\",{\"0\":{\"50\":1}}],[\"部署\",{\"1\":{\"178\":1}}],[\"搭建高可用集群\",{\"1\":{\"178\":1}}],[\"加入一定的随机性\",{\"1\":{\"178\":1}}],[\"加载完rdb的内容后在加载后半部部分的aof内容\",{\"1\":{\"87\":1}}],[\"热点数据用不过期\",{\"1\":{\"178\":1,\"181\":1}}],[\"热门数据在缓存中失效\",{\"1\":{\"177\":1}}],[\"解决方案\",{\"0\":{\"178\":1,\"181\":1,\"184\":1}}],[\"甚至崩溃的现象\",{\"1\":{\"176\":1}}],[\"指缓存中大量数据在同一时间突然失效或者突然不可用时\",{\"1\":{\"176\":1}}],[\"指南\",{\"0\":{\"34\":1},\"2\":{\"7\":1}}],[\"问题描述\",{\"1\":{\"176\":1,\"179\":1,\"182\":1}}],[\"双写一致性\",{\"1\":{\"173\":1}}],[\"来批量异步更新的方式将\",{\"1\":{\"172\":1}}],[\"来解析\",{\"1\":{\"12\":1}}],[\"或者降级处理\",{\"1\":{\"178\":1}}],[\"或者用一个数据库甚至使用一个文件来实现\",{\"1\":{\"66\":1}}],[\"或不存在\",{\"1\":{\"172\":1}}],[\"脏数据\",{\"1\":{\"172\":2}}],[\"异步缓存写入和读写穿透很相似\",{\"1\":{\"172\":1}}],[\"异步缓存写入write\",{\"0\":{\"172\":1}}],[\"异步任务\",{\"1\":{\"170\":1}}],[\"策略则将这一过程交给缓存系统处理\",{\"1\":{\"171\":1}}],[\"策略需要应用程序负责数据加载到缓存的过程\",{\"1\":{\"171\":1}}],[\"策略的区别\",{\"1\":{\"171\":1}}],[\"策略与read\",{\"1\":{\"171\":1}}],[\"策略篇\",{\"0\":{\"49\":1}}],[\"订阅binlog+异步任务\",{\"1\":{\"170\":1}}],[\"延迟双删\",{\"1\":{\"170\":1}}],[\"延迟重启\",{\"1\":{\"72\":1}}],[\"模式\",{\"1\":{\"170\":1}}],[\"更新数据时\",{\"1\":{\"168\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"6\":1}}],[\"更新时间\",{\"1\":{\"3\":1}}],[\"旁路缓存\",{\"0\":{\"168\":1}}],[\"他直接影响系统的性能\",{\"1\":{\"167\":1}}],[\"他们的区别就是是否在\",{\"1\":{\"85\":1}}],[\"选择缓存的读写策略是缓存设计中的关键步骤\",{\"1\":{\"167\":1}}],[\"旨在提高数据访问速度\",{\"1\":{\"166\":1}}],[\"经典的缓存策略有哪些\",{\"0\":{\"166\":1}}],[\"缓存起来\",{\"1\":{\"184\":1}}],[\"缓存空值\",{\"1\":{\"184\":1}}],[\"缓存空间等\",{\"1\":{\"172\":1}}],[\"缓存中的数据和数据库中的数据都被误删除了\",{\"1\":{\"183\":1}}],[\"缓存中的某个热点数据在失效的瞬间\",{\"1\":{\"179\":1}}],[\"缓存穿透\",{\"0\":{\"182\":1}}],[\"缓存击穿\",{\"0\":{\"179\":1}}],[\"缓存击穿与缓存穿透\",{\"0\":{\"175\":1}}],[\"缓存预热\",{\"1\":{\"178\":1}}],[\"缓存服务器宕机\",{\"1\":{\"177\":1}}],[\"缓存集中过期\",{\"1\":{\"177\":1}}],[\"缓存雪崩\",{\"0\":{\"175\":1,\"176\":1}}],[\"缓存系统会根据一定的策略\",{\"1\":{\"172\":1}}],[\"缓存系统会从持久存储中获取最新的数据\",{\"1\":{\"172\":1}}],[\"缓存系统负责从数据源中读取数据\",{\"1\":{\"171\":1}}],[\"缓存的读写策略\",{\"0\":{\"167\":1}}],[\"缓存\",{\"1\":{\"166\":1}}],[\"缓存类型有哪些\",{\"0\":{\"166\":1}}],[\"缓存篇\",{\"0\":{\"51\":1}}],[\"五\",{\"0\":{\"162\":1}}],[\"五种常见的数据结构\",{\"1\":{\"96\":1}}],[\"深入剖析\",{\"1\":{\"160\":1}}],[\"已经改成了顺序遍历字典表的方式\",{\"1\":{\"159\":1}}],[\"已过期\",{\"1\":{\"159\":1}}],[\"可能会引起大量请求同时访问该数据\",{\"1\":{\"180\":1}}],[\"可能会遇到各种问题\",{\"1\":{\"175\":1}}],[\"可能存在一些过期的key长时间未被删除掉\",{\"1\":{\"159\":1}}],[\"可以发现缓存击穿跟缓存雪崩很相似\",{\"1\":{\"181\":1}}],[\"可以保证过期key会被尽快删除\",{\"1\":{\"158\":1}}],[\"可以通过缓存预热的方式将热点数据提前加载到缓存中\",{\"1\":{\"178\":1}}],[\"可以通过config\",{\"1\":{\"150\":1}}],[\"可以通过cat命令查看里面的内容\",{\"1\":{\"79\":1}}],[\"可以通过以下两种方式配置最大运行内存\",{\"1\":{\"149\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"9\":1}}],[\"值得说明的是\",{\"1\":{\"159\":1}}],[\"导致请求在访问缓存时\",{\"1\":{\"182\":1}}],[\"导致缓存击穿\",{\"1\":{\"180\":1}}],[\"导致缓存中的数据是旧的\",{\"1\":{\"170\":1}}],[\"导致数据库压力剧增\",{\"1\":{\"176\":1}}],[\"导致线程卡死现象\",{\"1\":{\"159\":1}}],[\"导航栏\",{\"1\":{\"3\":1,\"6\":1}}],[\"比例小于\",{\"1\":{\"159\":1}}],[\"比如pexpireat\",{\"1\":{\"156\":1}}],[\"比如pexpire\",{\"1\":{\"156\":1}}],[\"比如expireat\",{\"1\":{\"156\":1}}],[\"比如expire\",{\"1\":{\"156\":1}}],[\"大量请求会同时打到后端数据库\",{\"1\":{\"177\":1}}],[\"大量热点数据失效\",{\"1\":{\"177\":1}}],[\"大量的请求直接打到后端数据库\",{\"1\":{\"176\":1}}],[\"大于\",{\"1\":{\"159\":1}}],[\"大key对持久化的影响\",{\"0\":{\"92\":1}}],[\"占比\",{\"1\":{\"159\":1}}],[\"超过\",{\"1\":{\"159\":1}}],[\"检查这\",{\"1\":{\"159\":1}}],[\"检查key是否过期\",{\"1\":{\"159\":1}}],[\"从过期字典中随机抽取\",{\"1\":{\"159\":1}}],[\"从数据库中取出一定数量的key进行检查\",{\"1\":{\"158\":1}}],[\"次过期检查一次数据库\",{\"1\":{\"159\":1}}],[\"正常返回键值给客户端\",{\"1\":{\"159\":1}}],[\"404\",{\"1\":{\"199\":1}}],[\"4\",{\"1\":{\"159\":2}}],[\"参数校验\",{\"1\":{\"184\":1}}],[\"参数配置决定\",{\"1\":{\"159\":1}}],[\"参考链接\",{\"0\":{\"88\":1,\"153\":1,\"160\":1},\"1\":{\"73\":1,\"76\":1,\"173\":1,\"184\":1}}],[\"至于是异步删除还是同步删除\",{\"1\":{\"159\":1}}],[\"至此\",{\"1\":{\"71\":1}}],[\"又会和惰性删除一样\",{\"1\":{\"158\":1}}],[\"难以确定删除执行时长和频率\",{\"1\":{\"158\":1}}],[\"并在后台定时刷新这些数据\",{\"1\":{\"178\":1,\"181\":1}}],[\"并更新缓存中的数据\",{\"1\":{\"172\":1}}],[\"并同步更新数据库\",{\"1\":{\"171\":1}}],[\"并返回给应用程序\",{\"1\":{\"171\":1}}],[\"并手动将数据放入缓存中\",{\"1\":{\"168\":1}}],[\"并删除已过期的\",{\"1\":{\"159\":1}}],[\"并删除其中过期的key\",{\"1\":{\"158\":1}}],[\"并不一定证明数据库中存在这个数据\",{\"1\":{\"76\":1}}],[\"定期删除策略会变的和定时删除策略一样\",{\"1\":{\"158\":1}}],[\"定期扫描\",{\"1\":{\"158\":1,\"159\":1}}],[\"定时删除策略对cpu不友好\",{\"1\":{\"158\":1}}],[\"定时删除策略对内存友好\",{\"1\":{\"158\":1}}],[\"定时删除\",{\"1\":{\"158\":1}}],[\"它将频繁访问或最近使用的数据临时存储在更快速但较小的存储介质\",{\"1\":{\"166\":1}}],[\"它的默认值是10\",{\"1\":{\"159\":1}}],[\"它的优点是重启\",{\"1\":{\"149\":1,\"151\":1}}],[\"它的优点是设置之后立即生效\",{\"1\":{\"149\":1,\"151\":1}}],[\"它所占用的内存就不会释放\",{\"1\":{\"158\":1}}],[\"都检测key是否过期\",{\"1\":{\"158\":1}}],[\"惰性删除策略对内存不友好\",{\"1\":{\"158\":1}}],[\"惰性删除策略对cpu友好\",{\"1\":{\"158\":1}}],[\"惰性删除\",{\"1\":{\"158\":1,\"159\":1,\"160\":1}}],[\"无疑会对服务器的响应时间和吞吐量造成影响\",{\"1\":{\"158\":1}}],[\"删除缓存失败的情况\",{\"0\":{\"170\":1}}],[\"删除过期key会占用相当一部分cpu时间\",{\"1\":{\"158\":1}}],[\"删除锁\",{\"0\":{\"71\":1}}],[\"过期删除策略\",{\"1\":{\"160\":1}}],[\"过期删除策略有哪些\",{\"0\":{\"158\":1}}],[\"过期key得不到及时释放\",{\"1\":{\"158\":1}}],[\"过期字典实际上是一个哈希表\",{\"1\":{\"157\":1}}],[\"过期字典\",{\"1\":{\"157\":1}}],[\"反之则证明该key已过期\",{\"1\":{\"157\":1}}],[\"省略了其他属性\",{\"1\":{\"157\":1}}],[\"所有请求都会直接打到后端数据库\",{\"1\":{\"177\":1}}],[\"所有的键值对\",{\"1\":{\"157\":1}}],[\"所以导致缓存和数据库中都没有数据\",{\"1\":{\"183\":1}}],[\"所以此策略只会使用很少的系统资源\",{\"1\":{\"158\":1}}],[\"所以\",{\"1\":{\"158\":2}}],[\"所以32位操作系统限制最大3gb的可用内存是非常合理的\",{\"1\":{\"148\":1}}],[\"所以可以认为执行快照是一个比较重的操作\",{\"1\":{\"85\":1}}],[\"所以如果写入rdb文件的时间过久\",{\"1\":{\"85\":1}}],[\"所以aof持久化功能也存在一定的风险\",{\"1\":{\"80\":1}}],[\"所以我们在加锁的时间为每一个锁添加一个唯一标识以确保不会出现误删的情况\",{\"1\":{\"70\":1}}],[\"所以我们不能单单依赖进程自己去释放锁\",{\"1\":{\"68\":1}}],[\"所以锁的声明和释放一定要基于各个工作流的可见区域来实现\",{\"1\":{\"66\":1}}],[\"则直接从缓存中获取数据并返回给应用程序\",{\"1\":{\"172\":1}}],[\"则直接返回给应用程序\",{\"1\":{\"168\":1,\"171\":1}}],[\"则应用程序负责将数据写入数据库\",{\"1\":{\"171\":1}}],[\"则数据将被写入缓存\",{\"1\":{\"171\":1,\"172\":1}}],[\"则停止继续删除过期\",{\"1\":{\"159\":1}}],[\"则继续重复步骤\",{\"1\":{\"159\":1}}],[\"则会获取该key的过期时间\",{\"1\":{\"157\":1}}],[\"则正常读取键值\",{\"1\":{\"157\":1}}],[\"则可以使用\",{\"1\":{\"156\":1}}],[\"则报错\",{\"1\":{\"150\":7}}],[\"取消key的过期时间\",{\"1\":{\"156\":2}}],[\"返回默认值或提示用户稍后重试\",{\"1\":{\"178\":1}}],[\"返回key过期还剩多少毫秒\",{\"1\":{\"156\":1}}],[\"返回key过期还剩多少秒\",{\"1\":{\"156\":1}}],[\"返回顶部按钮\",{\"1\":{\"3\":1,\"6\":1}}],[\"有大量请求并发访问该数据\",{\"1\":{\"179\":1}}],[\"有可能删除失败\",{\"1\":{\"170\":1}}],[\"有两种命令\",{\"1\":{\"156\":1}}],[\"有序集合\",{\"1\":{\"96\":1}}],[\"共有三种命令\",{\"1\":{\"156\":1}}],[\"共有4种命令\",{\"1\":{\"156\":1}}],[\"精确到毫秒\",{\"1\":{\"156\":2}}],[\"精确到秒\",{\"1\":{\"156\":2}}],[\"根据\",{\"1\":{\"159\":1}}],[\"根据lfu算法删除所有的键\",{\"1\":{\"150\":1}}],[\"根据lfu算法删除设置了过期时间的键\",{\"1\":{\"150\":1}}],[\"根据lru算法删除所有的键\",{\"1\":{\"150\":1}}],[\"根据lru算法删除设置了过期时间的键\",{\"1\":{\"150\":1}}],[\"根据键值对象的ttl属性\",{\"1\":{\"150\":1}}],[\"优先淘汰更早过期的键值\",{\"1\":{\"150\":1}}],[\"优点\",{\"1\":{\"80\":1,\"158\":3}}],[\"直接打到了后端数据库\",{\"1\":{\"179\":1}}],[\"直接删除这个文件就好了\",{\"1\":{\"81\":1}}],[\"直到腾出可用空间\",{\"1\":{\"150\":6}}],[\"随机化过期时间\",{\"1\":{\"178\":1}}],[\"随机抽取\",{\"1\":{\"159\":1}}],[\"随机\",{\"1\":{\"158\":1}}],[\"随机删除所有键\",{\"1\":{\"150\":1}}],[\"随机删除设置了过期时间的键\",{\"1\":{\"150\":1}}],[\"随着版本更新\",{\"1\":{\"96\":1}}],[\"随着写操作命令越来越多\",{\"1\":{\"81\":1}}],[\"运行内存达到最大设置内存时不淘汰任何数据\",{\"1\":{\"150\":1}}],[\"两者最大的不同点就是\",{\"1\":{\"172\":1}}],[\"两者都是由cache服务来负责cache和db的读写\",{\"1\":{\"172\":1}}],[\"两类策略\",{\"1\":{\"150\":1}}],[\"两个配置参数所设定的阈值时\",{\"1\":{\"81\":1}}],[\"设置一个短暂的过期时间\",{\"1\":{\"184\":1}}],[\"设置缓存数据的过期时间时\",{\"1\":{\"178\":1}}],[\"设置永不过期\",{\"1\":{\"178\":1,\"181\":1}}],[\"设置了过期时间的键值对\",{\"1\":{\"157\":1}}],[\"设置key时同时设置多少毫秒后过期\",{\"1\":{\"156\":1}}],[\"设置key时同时设置多少秒后过期\",{\"1\":{\"156\":2}}],[\"设置key在某个时间戳\",{\"1\":{\"156\":2}}],[\"设置key在milliseconds后过期\",{\"1\":{\"156\":1}}],[\"设置key在seconds后过期\",{\"1\":{\"156\":1}}],[\"设置key过期时间\",{\"1\":{\"156\":1}}],[\"设置\",{\"1\":{\"151\":1}}],[\"设置才能生效\",{\"1\":{\"149\":1,\"151\":1}}],[\"设置就会失效\",{\"1\":{\"149\":1,\"151\":1}}],[\"服务后配置不会丢失\",{\"1\":{\"149\":1,\"151\":1}}],[\"服务\",{\"1\":{\"149\":2,\"151\":2}}],[\"服务器故障时又会丢失很多数据\",{\"1\":{\"85\":1}}],[\"服务器的硬盘i\",{\"1\":{\"80\":1}}],[\"服务器发生了宕机\",{\"1\":{\"80\":1}}],[\"知道redis实例因内存不足崩溃也不做任何操作\",{\"1\":{\"148\":1}}],[\"才会触发内存淘汰策略\",{\"1\":{\"148\":1}}],[\"只有在redis的运行内存达到了我们设置的最大运行内存\",{\"1\":{\"148\":1}}],[\"只有执行成功后才将命令记录到aof日志里\",{\"1\":{\"80\":1}}],[\"三\",{\"0\":{\"145\":1}}],[\"quicklist\",{\"0\":{\"142\":1}}],[\"跳表\",{\"0\":{\"141\":1}}],[\"整个系统依然可用\",{\"1\":{\"178\":1}}],[\"整个恢复过程就会很慢\",{\"1\":{\"81\":1}}],[\"整数集合\",{\"0\":{\"140\":1}}],[\"压缩列表\",{\"0\":{\"138\":1}}],[\"链表\",{\"0\":{\"137\":1}}],[\"链接\",{\"1\":{\"3\":1,\"15\":1}}],[\"内存清理方面没定时删除效果好\",{\"1\":{\"158\":1}}],[\"内存耗尽后redis会发生什么\",{\"1\":{\"153\":1}}],[\"内部实现\",{\"0\":{\"100\":1,\"104\":1,\"108\":1,\"112\":1,\"116\":1,\"120\":1,\"124\":1,\"128\":1,\"132\":1}}],[\"内容\",{\"1\":{\"12\":1}}],[\"常用指令\",{\"0\":{\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"114\":1,\"118\":1,\"122\":1,\"126\":1,\"130\":1}}],[\"5\",{\"1\":{\"96\":1,\"159\":1}}],[\"geo\",{\"0\":{\"125\":1},\"1\":{\"96\":1}}],[\"get\",{\"1\":{\"71\":2,\"76\":2,\"150\":1}}],[\"8版新增\",{\"1\":{\"96\":1}}],[\"zset\",{\"0\":{\"113\":1},\"1\":{\"96\":1}}],[\"集群模式\",{\"0\":{\"197\":1}}],[\"集群模式等\",{\"1\":{\"178\":1}}],[\"集合\",{\"1\":{\"96\":1}}],[\"集成了aof和rdb的优点\",{\"1\":{\"90\":1}}],[\"列表\",{\"1\":{\"96\":1}}],[\"哈希表最大的好处就是让我们可以用o\",{\"1\":{\"157\":1}}],[\"哈希表\",{\"0\":{\"139\":1}}],[\"哈希\",{\"1\":{\"96\":1}}],[\"字符串\",{\"1\":{\"96\":1}}],[\"记录的是二进制数据\",{\"1\":{\"90\":1}}],[\"记录的是操作命令\",{\"1\":{\"90\":1}}],[\"记录的是实际数据\",{\"1\":{\"85\":1}}],[\"支持三种持久化方式\",{\"1\":{\"90\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"23\":1}}],[\"二\",{\"0\":{\"90\":1}}],[\"二进制数据\",{\"1\":{\"85\":1}}],[\"格式吗\",{\"1\":{\"88\":1}}],[\"期间\",{\"1\":{\"87\":1}}],[\"后过期\",{\"1\":{\"156\":2}}],[\"后面又支持了四种数据结构\",{\"1\":{\"96\":1}}],[\"后面跟具体命令\",{\"1\":{\"79\":1}}],[\"后半部分是aof格式的增量数据\",{\"1\":{\"87\":1}}],[\"后台子进程重写\",{\"1\":{\"87\":1}}],[\"该方法又叫混合持久化\",{\"1\":{\"87\":1}}],[\"该配置项默认为everysec\",{\"1\":{\"80\":1}}],[\"混合持久化存储\",{\"1\":{\"90\":1}}],[\"混合持久化工作在aof日志重写的过程\",{\"1\":{\"87\":1}}],[\"混合持久化\",{\"1\":{\"87\":1}}],[\"合体\",{\"0\":{\"87\":1}}],[\"900秒内\",{\"1\":{\"85\":1}}],[\"900\",{\"1\":{\"85\":1}}],[\"会导致大量请求直接打到数据库\",{\"1\":{\"177\":1}}],[\"会创建一个子进程来生成rdb文件\",{\"1\":{\"85\":1}}],[\"会阻塞主线程\",{\"1\":{\"85\":1}}],[\"会使用内存淘汰策略淘汰符合条件的key\",{\"1\":{\"147\":1}}],[\"会使用\",{\"1\":{\"12\":1}}],[\"里执行\",{\"1\":{\"85\":1}}],[\"操作日志\",{\"1\":{\"85\":1}}],[\"而用户不断访问id为\",{\"1\":{\"183\":1}}],[\"而是改为异步批量的方式更新db\",{\"1\":{\"172\":1}}],[\"而是拷贝到了内核缓冲区page\",{\"1\":{\"80\":1}}],[\"而异步缓存写入则是只更新cache\",{\"1\":{\"172\":1}}],[\"而\",{\"1\":{\"171\":1}}],[\"而做这个工作的就是过期键值对删除策略\",{\"1\":{\"155\":1}}],[\"而系统本身又需要一定的内存资源来支持运行\",{\"1\":{\"148\":1}}],[\"而不是实际数据\",{\"1\":{\"85\":1}}],[\"而aof文件记录的是命令的操作日志\",{\"1\":{\"85\":1}}],[\"执行快照期间\",{\"0\":{\"86\":1}}],[\"执行了bgsave命令\",{\"1\":{\"85\":1}}],[\"执行了save命令\",{\"1\":{\"85\":1}}],[\"执行命令追加到aof重写缓冲区\",{\"1\":{\"82\":1}}],[\"执行客户端发来的命令\",{\"1\":{\"82\":1}}],[\"行命令追加到aof缓存区\",{\"1\":{\"82\":1}}],[\"子进程以只读的方式共享内存\",{\"1\":{\"82\":1}}],[\"子线程会共享内存\",{\"1\":{\"82\":1}}],[\"降低执行效率\",{\"1\":{\"82\":1}}],[\"用一条命令去记录最新键值对\",{\"1\":{\"81\":1}}],[\"使得aof文件变小\",{\"1\":{\"81\":1}}],[\"使用布隆过滤器快速判断数据是否存在\",{\"1\":{\"184\":1}}],[\"使用限流机制保护数据库\",{\"1\":{\"178\":1}}],[\"使用资源方面没有惰性删除使用的少\",{\"1\":{\"158\":1}}],[\"使用这个机制将数据存储到磁盘上\",{\"1\":{\"90\":1}}],[\"使用后台子进程原因\",{\"1\":{\"82\":1}}],[\"使用\",{\"1\":{\"73\":1}}],[\"使用加参数的set\",{\"0\":{\"69\":1}}],[\"使用指南\",{\"1\":{\"29\":2},\"2\":{\"2\":1,\"4\":1,\"25\":1,\"32\":1,\"33\":1}}],[\"之前的\",{\"1\":{\"81\":1}}],[\"之后过期\",{\"1\":{\"156\":2}}],[\"之后\",{\"1\":{\"149\":1,\"151\":1}}],[\"之后的创建的或者没在r1上存储的锁都不会受到影响\",{\"1\":{\"72\":1}}],[\"之后再次重启\",{\"1\":{\"72\":1}}],[\"等同于set\",{\"1\":{\"156\":1}}],[\"等到全部记录完后\",{\"1\":{\"81\":1}}],[\"等待内核将数据写入到硬盘\",{\"1\":{\"80\":1}}],[\"新的aof文件中\",{\"1\":{\"81\":1}}],[\"读写穿透是同步更新db和cache\",{\"1\":{\"172\":1}}],[\"读写穿透\",{\"0\":{\"171\":1}}],[\"读\",{\"1\":{\"168\":1,\"171\":1,\"172\":1}}],[\"读取数据的次数\",{\"1\":{\"166\":1}}],[\"读取当前数据库中所有的键值对\",{\"1\":{\"81\":1}}],[\"读操作命令是不会被记录的\",{\"1\":{\"79\":1}}],[\"将空结果\",{\"1\":{\"184\":1}}],[\"将cpu用于删除和当前任务无关的过期键上\",{\"1\":{\"158\":1}}],[\"将某一时刻的数据\",{\"1\":{\"90\":1}}],[\"将尝试执行\",{\"1\":{\"81\":1}}],[\"将会尝试执行\",{\"1\":{\"81\":1}}],[\"将命令追加到server\",{\"1\":{\"80\":1}}],[\"时间过久可能会影响业务\",{\"1\":{\"184\":1}}],[\"时\",{\"1\":{\"81\":2}}],[\"表示没有内存大小限制\",{\"1\":{\"148\":1}}],[\"表示当当前\",{\"1\":{\"81\":1}}],[\"表示这部分有3个字节\",{\"1\":{\"79\":1}}],[\"表示这部分命令\",{\"1\":{\"79\":1}}],[\"重试机制\",{\"1\":{\"170\":1}}],[\"重写缓冲区里的增量命令会以aof方式写入到aof文件\",{\"1\":{\"87\":1}}],[\"重写缓冲区\",{\"1\":{\"82\":1}}],[\"重写是由后台子进程完成的\",{\"1\":{\"82\":1}}],[\"重写过程是先写到新的aof文件\",{\"1\":{\"81\":1}}],[\"重写机制的作用就是尽管某个键值对被多条命令反复修改了多次\",{\"1\":{\"81\":1}}],[\"重写完成后会使用新的aof文件替换现有的aof文件\",{\"1\":{\"81\":1}}],[\"重写操作\",{\"1\":{\"81\":2}}],[\"重写的默认触发条件是当\",{\"1\":{\"81\":1}}],[\"重要的内容\",{\"1\":{\"21\":1}}],[\"修改redis\",{\"1\":{\"80\":1}}],[\"机器宕机可能会丢失很多数据\",{\"1\":{\"80\":1}}],[\"机器宕机会丢失1秒内的数据\",{\"1\":{\"80\":1}}],[\"性能好\",{\"1\":{\"80\":1}}],[\"性能适中\",{\"1\":{\"80\":1}}],[\"性能开销大\",{\"1\":{\"80\":1}}],[\"缺点是必须重启\",{\"1\":{\"149\":1,\"151\":1}}],[\"缺点是重启\",{\"1\":{\"149\":1,\"151\":1}}],[\"缺点\",{\"1\":{\"80\":1,\"158\":3}}],[\"写\",{\"1\":{\"168\":1,\"171\":1,\"172\":1}}],[\"写入完成后通知主进程将新的含有rdb格式和aof格式的aof文件替换旧的aof文件\",{\"1\":{\"87\":1}}],[\"写回到持久存储中\",{\"1\":{\"172\":1}}],[\"写回时机\",{\"1\":{\"80\":1}}],[\"写回策略\",{\"1\":{\"80\":1}}],[\"写作日期为\",{\"1\":{\"29\":1}}],[\"一\",{\"0\":{\"94\":1}}],[\"一旦服务器宕机就会丢失不定数量的数据\",{\"1\":{\"80\":1}}],[\"一个锁只能被一个工作流持有\",{\"1\":{\"66\":1}}],[\"一个拥有\",{\"1\":{\"19\":1}}],[\"相比较always性能较好\",{\"1\":{\"80\":1}}],[\"相关信息\",{\"1\":{\"11\":1}}],[\"折中的方案\",{\"1\":{\"80\":1}}],[\"先将命令写入到aof文件到内核缓冲区\",{\"1\":{\"80\":2}}],[\"最后在完成工作后用最新的aof文件覆盖现有的aof文件\",{\"1\":{\"81\":1}}],[\"最终也只需要根据这个键值对当前最新状态\",{\"1\":{\"81\":1}}],[\"最终完成版\",{\"1\":{\"71\":1}}],[\"最大程度保证数据不丢失\",{\"1\":{\"80\":2}}],[\"每隔一段时间\",{\"1\":{\"158\":1}}],[\"每次从数据库访问key时\",{\"1\":{\"158\":1}}],[\"每次执行时都会把内存中的所有数据记录到磁盘\",{\"1\":{\"85\":1}}],[\"每次执行完命令\",{\"1\":{\"80\":3}}],[\"每执行一条写操作命令\",{\"1\":{\"90\":1}}],[\"每秒写回\",{\"1\":{\"80\":1}}],[\"每个写命令都要写回硬盘\",{\"1\":{\"80\":1}}],[\"每个部分都是以\",{\"1\":{\"79\":1}}],[\"每个\",{\"1\":{\"31\":1}}],[\"控制的就是上面说的第三步的过程\",{\"1\":{\"80\":1}}],[\"由事件处理器自动执行key的删除操作\",{\"1\":{\"158\":1}}],[\"由操作系统控制写回\",{\"1\":{\"80\":1}}],[\"由操作系统决定何时将缓冲区内容写回硬盘\",{\"1\":{\"80\":1}}],[\"由内核决定\",{\"1\":{\"80\":1}}],[\"由于随机选择的特性\",{\"1\":{\"159\":1}}],[\"由于前半部分是rdb格式的\",{\"1\":{\"87\":1}}],[\"由于和执行命令在同一个线程\",{\"1\":{\"85\":1}}],[\"由于执行写操作命令和记录日志是两个过程\",{\"1\":{\"80\":1}}],[\"由于当前进程没有释放锁\",{\"1\":{\"68\":1}}],[\"具体内核缓冲区的数据什么时候写入到硬盘\",{\"1\":{\"80\":1}}],[\"具体实现方式很多\",{\"1\":{\"66\":1}}],[\"系统命令调用将aof\",{\"1\":{\"80\":1}}],[\"然后立马返回\",{\"1\":{\"172\":1}}],[\"然后返回给应用程序\",{\"1\":{\"172\":1}}],[\"然后返回null给客户端\",{\"1\":{\"159\":1}}],[\"然后将数据写入缓存\",{\"1\":{\"171\":1}}],[\"然后将每一个键值对记录到\",{\"1\":{\"81\":1}}],[\"然后应用程序使缓存中的相关数据失效\",{\"1\":{\"168\":1}}],[\"然后等待下一轮再检查\",{\"1\":{\"159\":1}}],[\"然后与当前系统时间比对\",{\"1\":{\"157\":1}}],[\"然后再覆盖过去\",{\"1\":{\"81\":1}}],[\"然后用一条\",{\"1\":{\"81\":1}}],[\"然后每隔一秒再将缓冲区内容写回到硬盘\",{\"1\":{\"80\":1}}],[\"然后通过write\",{\"1\":{\"80\":1}}],[\"然后r1机器未将数据持久化到磁盘出现宕机\",{\"1\":{\"72\":1}}],[\"认真分析可以发现两个风险都有一个共性\",{\"1\":{\"80\":1}}],[\"o压力太大\",{\"1\":{\"80\":1}}],[\"only\",{\"1\":{\"79\":1}}],[\"虽然写操作命令执行成功后才会记录到aof日志\",{\"1\":{\"80\":1}}],[\"不直接更新db\",{\"1\":{\"172\":1}}],[\"不做任何处理\",{\"1\":{\"159\":1}}],[\"不主动删除key\",{\"1\":{\"158\":1}}],[\"不进行数据淘汰\",{\"1\":{\"150\":1}}],[\"不需要重启\",{\"1\":{\"149\":1,\"151\":1}}],[\"不需要像aof那样还需要额外执行操作命令的步骤才能恢复数据\",{\"1\":{\"85\":1}}],[\"不同位数的操作系统\",{\"1\":{\"148\":1}}],[\"不用再通过加锁来保证数据安全\",{\"1\":{\"82\":1}}],[\"不用在写入前检查命令语法是否正确\",{\"1\":{\"80\":1}}],[\"不阻塞主进程处理命令\",{\"1\":{\"82\":1}}],[\"不会对现有的aof文件造成影响\",{\"1\":{\"81\":1}}],[\"不会阻塞当前命令的执行\",{\"1\":{\"80\":1}}],[\"不会阻塞当前写操作命令的执行\",{\"1\":{\"80\":1}}],[\"保证同一时间只有一个业务线程更新缓存\",{\"1\":{\"181\":1}}],[\"保证每条写入aof日志里的命令都是可执行且正确的\",{\"1\":{\"80\":1}}],[\"保存了数据库中所有key的过期时间\",{\"1\":{\"157\":1}}],[\"保留键的副本\",{\"1\":{\"71\":1}}],[\"命令设置\",{\"1\":{\"149\":1,\"151\":1}}],[\"命令记录到新的aof文件中\",{\"1\":{\"81\":1}}],[\"命令带来阻塞风险\",{\"1\":{\"80\":1}}],[\"命令这个字符串的长度\",{\"1\":{\"79\":1}}],[\"命令可以保证原子性\",{\"1\":{\"71\":1}}],[\"也比no策略更能避免数据丢失\",{\"1\":{\"80\":1}}],[\"也就是内存尽快释放\",{\"1\":{\"158\":1}}],[\"也就是说\",{\"1\":{\"157\":1}}],[\"也就是说使用了混合持久化的aof文件前半部分说rdb格式的全量数据\",{\"1\":{\"87\":1}}],[\"也就是说这两个操作是同步的\",{\"1\":{\"80\":1}}],[\"也就是\",{\"1\":{\"79\":1,\"159\":1}}],[\"也可以考虑事务实现\",{\"1\":{\"71\":1}}],[\"数字\",{\"1\":{\"79\":1}}],[\"数据量\",{\"1\":{\"172\":1}}],[\"数据不一致的情况\",{\"0\":{\"169\":1}}],[\"数据一致性和可用性\",{\"1\":{\"167\":1}}],[\"数据库压力骤增\",{\"1\":{\"177\":1}}],[\"数据库和缓存如何保证一致性｜小林\",{\"1\":{\"173\":1}}],[\"数据库与缓存一致性\",{\"0\":{\"164\":1}}],[\"数据库中一定就不存在这个数据\",{\"1\":{\"76\":1}}],[\"数据能被修改吗\",{\"0\":{\"86\":1}}],[\"数据结构篇\",{\"0\":{\"47\":1}}],[\"键或值一共有多少字节\",{\"1\":{\"79\":1}}],[\"键或值\",{\"1\":{\"79\":1}}],[\"开头\",{\"1\":{\"79\":1}}],[\"代替之前记录的多条命令\",{\"1\":{\"81\":1}}],[\"代表当前命令有三个部分\",{\"1\":{\"79\":1}}],[\"代码块\",{\"0\":{\"16\":1}}],[\"代码\",{\"1\":{\"15\":1}}],[\"$+数字\",{\"1\":{\"79\":1}}],[\"$6\",{\"1\":{\"79\":1}}],[\"$4\",{\"1\":{\"79\":1}}],[\"$3\",{\"1\":{\"79\":2}}],[\"例如数据库的id一般都是从1自增上去的\",{\"1\":{\"183\":1}}],[\"例如数据库\",{\"1\":{\"168\":1}}],[\"例如在没执行重写机制前前后执行了\",{\"1\":{\"81\":1}}],[\"例如\",{\"1\":{\"79\":1}}],[\"例如我们执行set\",{\"1\":{\"79\":1}}],[\"例如一个进程中的多线程可以利用全局变量在实现\",{\"1\":{\"66\":1}}],[\"即有一定的延迟性\",{\"1\":{\"172\":1}}],[\"即缓存中不存在需要写入的数据\",{\"1\":{\"171\":1}}],[\"即删除缓存中的数据\",{\"1\":{\"168\":1}}],[\"即翻倍\",{\"1\":{\"81\":1}}],[\"即每秒将写入操作同步到磁盘一次\",{\"1\":{\"80\":1}}],[\"即不开启\",{\"1\":{\"79\":1}}],[\"即写入\",{\"1\":{\"72\":1}}],[\"需要我们去修改redis\",{\"1\":{\"79\":1}}],[\"如null或特定的占位符\",{\"1\":{\"184\":1}}],[\"如主从复制\",{\"1\":{\"178\":1}}],[\"如时间间隔\",{\"1\":{\"172\":1}}],[\"如硬盘或远程服务器\",{\"1\":{\"166\":1}}],[\"如内存\",{\"1\":{\"166\":1}}],[\"如何选择合适的策略\",{\"0\":{\"173\":1}}],[\"如何判断一个key已经过期\",{\"0\":{\"157\":1}}],[\"如何设置过期时间\",{\"0\":{\"156\":1}}],[\"如何配置redis内存淘汰策略\",{\"0\":{\"151\":1}}],[\"如何配置redis最大运行内存\",{\"0\":{\"149\":1}}],[\"如何配置redis写回策略\",{\"1\":{\"80\":1}}],[\"如何配置aof持久化\",{\"1\":{\"79\":1}}],[\"如重启redis后需要读aof文件的内容以恢复数据\",{\"1\":{\"81\":1}}],[\"如果这个数据突然失效\",{\"1\":{\"180\":1}}],[\"如果大量缓存数据设置了相同或接近的过期时间\",{\"1\":{\"177\":1}}],[\"如果数据在缓存中是\",{\"1\":{\"172\":1}}],[\"如果数据在缓存中存在且是最新的\",{\"1\":{\"172\":1}}],[\"如果缓存中存在相应数据\",{\"1\":{\"171\":1,\"172\":1}}],[\"如果缓存中存在数据\",{\"1\":{\"168\":1,\"171\":1}}],[\"如果缓存未命中\",{\"1\":{\"168\":1,\"171\":2}}],[\"如果已过期的\",{\"1\":{\"159\":1}}],[\"如果本轮检查的已过期\",{\"1\":{\"159\":1}}],[\"如果没有过期\",{\"1\":{\"159\":1}}],[\"如果没有可删除的键对象且内存还是不够用时\",{\"1\":{\"150\":7}}],[\"如果执行太少\",{\"1\":{\"158\":1}}],[\"如果执行太频繁\",{\"1\":{\"158\":1}}],[\"如果执行太频繁可能对redis性能产生影响\",{\"1\":{\"85\":1}}],[\"如果一个key已经过期\",{\"1\":{\"158\":1}}],[\"如果过期则删除该key\",{\"1\":{\"158\":1,\"159\":1}}],[\"如果将一个过期的key删除\",{\"1\":{\"158\":1}}],[\"如果将日志写入到磁盘时\",{\"1\":{\"80\":1}}],[\"如果比系统时间大则证明未过期\",{\"1\":{\"157\":1}}],[\"如果存在\",{\"1\":{\"157\":1}}],[\"如果不存在\",{\"1\":{\"157\":1}}],[\"如果不存在这个锁则加锁并设置过期时间\",{\"1\":{\"71\":1}}],[\"如果突然反悔\",{\"1\":{\"156\":1}}],[\"如果返回\",{\"1\":{\"156\":2}}],[\"如果想查看某个key对过期时间\",{\"1\":{\"156\":1}}],[\"如果此时有新数据写入会报错\",{\"1\":{\"150\":1}}],[\"如果频率太低\",{\"1\":{\"85\":1}}],[\"如果发生变更就会产生写时复制\",{\"1\":{\"82\":1}}],[\"如果重写失败\",{\"1\":{\"81\":1}}],[\"如果文件过大\",{\"1\":{\"81\":1}}],[\"如果每执行一个写操作命令\",{\"1\":{\"79\":1}}],[\"如果进程1从r1\",{\"1\":{\"72\":1}}],[\"如果进程a在持有锁的时间内未完成任务\",{\"1\":{\"70\":1}}],[\"如果使用多个redis\",{\"1\":{\"72\":1}}],[\"如果锁超时了我们如何给锁续期以及如何避免锁的无限续期\",{\"1\":{\"71\":1}}],[\"如果依赖单节点\",{\"1\":{\"71\":1}}],[\"如果超出循环时间则自动结束\",{\"1\":{\"67\":1}}],[\"如果你不了解它\",{\"1\":{\"11\":1}}],[\"如果你是一个新手\",{\"1\":{\"10\":1}}],[\"注意只会记录写操作命令\",{\"1\":{\"79\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"27\":1}}],[\"持久化功能\",{\"1\":{\"79\":1}}],[\"持久化篇\",{\"0\":{\"48\":1}}],[\"就把该命令以追加的方式写入到一个文件里\",{\"1\":{\"90\":1}}],[\"就把该命令追加写入到一个文件\",{\"1\":{\"79\":1}}],[\"就属于历史命令\",{\"1\":{\"81\":1}}],[\"就会在主线程生成rdb文件\",{\"1\":{\"85\":1}}],[\"就会读取最新的key\",{\"1\":{\"81\":1}}],[\"就会将这两个命令都写入到aof文件\",{\"1\":{\"81\":1}}],[\"就会导致写硬盘的速度很慢\",{\"1\":{\"80\":1}}],[\"就将新的aof文件替换掉现有的aof文件\",{\"1\":{\"81\":1}}],[\"就是都跟aof日志写回硬盘的时机有关\",{\"1\":{\"80\":1}}],[\"就相当于恢复缓存数据了\",{\"1\":{\"79\":1}}],[\"牛逼\",{\"1\":{\"76\":2}}],[\"dict\",{\"1\":{\"157\":3}}],[\"db\",{\"1\":{\"76\":1}}],[\"data\",{\"1\":{\"76\":2}}],[\"del\",{\"1\":{\"71\":2}}],[\"delete\",{\"1\":{\"67\":1}}],[\"def\",{\"1\":{\"67\":3,\"68\":1,\"69\":1,\"70\":1,\"71\":3,\"76\":2}}],[\"key是唯一的标识\",{\"1\":{\"97\":1}}],[\"key1\",{\"1\":{\"79\":2,\"81\":4}}],[\"key\",{\"1\":{\"76\":8,\"156\":4,\"159\":8}}],[\"keys=\",{\"1\":{\"71\":2}}],[\"keys\",{\"1\":{\"71\":4}}],[\"初始化布隆过滤器\",{\"1\":{\"76\":1}}],[\"实例代码\",{\"1\":{\"76\":1}}],[\"实现分布式锁\",{\"1\":{\"73\":1}}],[\"实现的分布式锁\",{\"1\":{\"71\":1}}],[\"但是这个key一直没有被访问到\",{\"1\":{\"158\":1}}],[\"但是如果没新数据写入\",{\"1\":{\"150\":1}}],[\"但是机器宕机时丢失数据较多\",{\"1\":{\"87\":1}}],[\"但是重启redis时恢复数据较慢\",{\"1\":{\"87\":1}}],[\"但是在使用重写机制后\",{\"1\":{\"81\":1}}],[\"但是操作系统何时落盘是不可预知的\",{\"1\":{\"80\":1}}],[\"但是由于频繁落盘不可避免的影响主进程性能\",{\"1\":{\"80\":1}}],[\"但是会给\",{\"1\":{\"80\":1}}],[\"但是查询到数据不存在\",{\"1\":{\"76\":1}}],[\"但是不管怎么实现都要保证如下几点\",{\"1\":{\"66\":1}}],[\"查询的数据既不在缓存也不在数据库\",{\"1\":{\"182\":1}}],[\"查询时使用布隆过滤器\",{\"1\":{\"76\":1}}],[\"查询布隆过滤器说数据存在\",{\"1\":{\"76\":1}}],[\"查看详情\",{\"1\":{\"15\":1,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1}}],[\"原理\",{\"1\":{\"76\":1}}],[\"原子性操作\",{\"0\":{\"71\":1}}],[\"布谷鸟\",{\"1\":{\"76\":1}}],[\"布隆\",{\"1\":{\"76\":1}}],[\"布隆过滤器\",{\"0\":{\"76\":1},\"1\":{\"76\":1}}],[\"布隆过滤器与布谷鸟过滤器\",{\"0\":{\"75\":1}}],[\"布局包括\",{\"1\":{\"6\":1}}],[\"布局\",{\"0\":{\"6\":1},\"2\":{\"8\":1}}],[\"布局与功能禁用\",{\"0\":{\"3\":1}}],[\"满足法团准则\",{\"1\":{\"72\":1}}],[\"假设我们有五台机器\",{\"1\":{\"72\":1}}],[\"个\",{\"1\":{\"159\":3}}],[\"个服务器的锁则认为获得锁成功\",{\"1\":{\"72\":1}}],[\"个节点后才成功\",{\"1\":{\"72\":1}}],[\"获得至少\",{\"1\":{\"72\":1}}],[\"获取锁的超时时间\",{\"1\":{\"71\":1}}],[\"下一个\",{\"1\":{\"80\":1}}],[\"下一篇\",{\"1\":{\"3\":1}}],[\"下面我们将试着讨论redlock\",{\"1\":{\"71\":1}}],[\"释放锁\",{\"1\":{\"71\":1}}],[\"<ttl>\",{\"1\":{\"156\":1}}],[\"<timestamp>\",{\"1\":{\"156\":2}}],[\"<value>\",{\"1\":{\"156\":4}}],[\"<milliseconds>\",{\"1\":{\"156\":2}}],[\"<seconds>\",{\"1\":{\"156\":3}}],[\"<key>\",{\"1\":{\"156\":11}}],[\"<策略>\",{\"1\":{\"151\":2}}],[\"<bytes>来设定最大的运行内存\",{\"1\":{\"149\":1}}],[\"<\",{\"1\":{\"71\":1}}],[\"秒\",{\"1\":{\"71\":2}}],[\"3种常用的缓存读写策略详解\",{\"1\":{\"173\":1}}],[\"300秒内\",{\"1\":{\"85\":1}}],[\"300\",{\"1\":{\"85\":1}}],[\"3600\",{\"1\":{\"76\":1}}],[\"3\",{\"1\":{\"71\":1,\"79\":2,\"80\":1,\"96\":1}}],[\"默认不会超过\",{\"1\":{\"159\":1}}],[\"默认每秒进行\",{\"1\":{\"159\":1}}],[\"默认策略\",{\"1\":{\"150\":1}}],[\"默认配置如下\",{\"1\":{\"85\":1}}],[\"默认为\",{\"1\":{\"79\":1}}],[\"默认该参数为\",{\"1\":{\"79\":1}}],[\"默认\",{\"1\":{\"71\":2}}],[\"连接\",{\"1\":{\"71\":2}}],[\"uuid4\",{\"1\":{\"71\":1}}],[\"uuid\",{\"1\":{\"71\":2}}],[\"unlock\",{\"1\":{\"67\":2,\"71\":8}}],[\"基本操作\",{\"1\":{\"98\":1,\"102\":1,\"106\":1,\"110\":1,\"114\":1,\"118\":1,\"122\":1,\"126\":1,\"130\":1}}],[\"基于redis的分布式锁设计\",{\"1\":{\"73\":1}}],[\"基于redis的分布式锁详解\",{\"1\":{\"73\":1}}],[\"基于redis实现单节点分布式锁基本完成\",{\"1\":{\"71\":1}}],[\"基于\",{\"1\":{\"71\":1}}],[\"基础\",{\"2\":{\"42\":1}}],[\"基础篇\",{\"0\":{\"40\":1}}],[\"coding\",{\"1\":{\"173\":1,\"184\":1}}],[\"coonf配置文件中的appendfsync配置项\",{\"1\":{\"80\":1}}],[\"conf\",{\"1\":{\"159\":1}}],[\"conf中可以通过参数maxmemory\",{\"1\":{\"149\":1}}],[\"config\",{\"1\":{\"149\":1,\"151\":1}}],[\"conf配置文件中的appendonly参数去开启aof持久化\",{\"1\":{\"79\":1}}],[\"conn\",{\"1\":{\"71\":6}}],[\"const\",{\"1\":{\"15\":1}}],[\"client\",{\"1\":{\"76\":3}}],[\"caching\",{\"0\":{\"172\":1}}],[\"cache\",{\"0\":{\"168\":1,\"169\":1,\"170\":1},\"1\":{\"80\":1,\"166\":1,\"168\":3,\"170\":1,\"171\":2}}],[\"capacity=100000\",{\"1\":{\"76\":1}}],[\"call\",{\"1\":{\"71\":4}}],[\"ceil\",{\"1\":{\"71\":1}}],[\"lazy\",{\"1\":{\"159\":1,\"160\":1}}],[\"lazyfree\",{\"1\":{\"159\":1}}],[\"lfu算法\",{\"1\":{\"152\":1}}],[\"lfu\",{\"1\":{\"150\":2}}],[\"lru算法\",{\"1\":{\"152\":1}}],[\"lru算法和lfu算法有什么区别\",{\"0\":{\"152\":1}}],[\"lru\",{\"1\":{\"150\":2}}],[\"listpack\",{\"0\":{\"143\":1}}],[\"list\",{\"0\":{\"101\":1},\"1\":{\"96\":1}}],[\"live\",{\"1\":{\"76\":1}}],[\"lua\",{\"1\":{\"71\":1}}],[\"lockname\",{\"1\":{\"71\":5}}],[\"lock\",{\"1\":{\"66\":1,\"67\":9,\"68\":4,\"69\":3,\"70\":3,\"71\":16}}],[\"脚本来执行判断和删除的操作\",{\"1\":{\"71\":1}}],[\"脚注\",{\"0\":{\"20\":1}}],[\"出现误删\",{\"1\":{\"70\":1}}],[\"给锁添加唯一标识\",{\"0\":{\"70\":1}}],[\"给锁加超时时间\",{\"0\":{\"68\":1}}],[\"null\",{\"1\":{\"76\":2}}],[\"noeviction\",{\"1\":{\"150\":1}}],[\"no\",{\"1\":{\"79\":1,\"80\":2}}],[\"none\",{\"1\":{\"76\":4}}],[\"not\",{\"1\":{\"76\":1,\"199\":1}}],[\"n\",{\"1\":{\"72\":2}}],[\"nx=true\",{\"1\":{\"69\":1,\"70\":1,\"71\":1}}],[\"name\",{\"1\":{\"67\":7,\"68\":3,\"69\":2,\"70\":2,\"71\":7}}],[\"64mb\",{\"1\":{\"81\":2}}],[\"60秒内对数据库进行了至少10000次修改就会执行bgsave\",{\"1\":{\"85\":1}}],[\"60\",{\"1\":{\"76\":1,\"85\":1}}],[\"6\",{\"1\":{\"69\":1}}],[\"在缓存失效的情况下\",{\"1\":{\"178\":1}}],[\"在缓存失效时\",{\"1\":{\"178\":1}}],[\"在系统启动时或低峰期\",{\"1\":{\"178\":1}}],[\"在此模式下\",{\"1\":{\"170\":1}}],[\"在删除缓存时\",{\"1\":{\"170\":1}}],[\"在删除锁的时间需要先判断再删除\",{\"1\":{\"71\":1}}],[\"在\",{\"1\":{\"159\":1}}],[\"在内存不紧张但cpu紧张的情况下\",{\"1\":{\"158\":1}}],[\"在过期key较多的情况下\",{\"1\":{\"158\":1}}],[\"在设置key的过期时间时同时创建一个定时事件\",{\"1\":{\"158\":1}}],[\"在配置文件redis\",{\"1\":{\"149\":1}}],[\"在32位操作系统中\",{\"1\":{\"148\":1}}],[\"在64位操作系统中\",{\"1\":{\"148\":1}}],[\"在执行aof重写期间\",{\"1\":{\"82\":1}}],[\"在重启后数据就会丢失\",{\"1\":{\"90\":1}}],[\"在重启redis的时候读取文件中的命令并去执行它\",{\"1\":{\"79\":1}}],[\"在重写期间主进程仍可执行命令\",{\"1\":{\"82\":1}}],[\"在发生变更操作时需要加锁\",{\"1\":{\"82\":1}}],[\"在数据写入数据库时更新布隆过滤器\",{\"1\":{\"76\":1}}],[\"在进程b加锁后进程a才完成任务\",{\"1\":{\"70\":1}}],[\"在redis使用过程中\",{\"1\":{\"175\":1}}],[\"在redis6\",{\"1\":{\"159\":1}}],[\"在redis4\",{\"1\":{\"87\":1}}],[\"在redis\",{\"1\":{\"69\":1}}],[\"在加锁后进程挂掉依然会出现死锁的问题\",{\"1\":{\"69\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"3\":1}}],[\"因为只有访问时才会检测key是否过期\",{\"1\":{\"158\":1}}],[\"因为只有写操作执行成功后才会将命令记录到aof日志\",{\"1\":{\"80\":1}}],[\"因为32位的机器最大只支持4gb的内存\",{\"1\":{\"148\":1}}],[\"因为rdb是直接将二进制文件读入内存就可以了\",{\"1\":{\"85\":1}}],[\"因为将命令写入到日志的操作也是在主进程进行的\",{\"1\":{\"80\":1}}],[\"因为记录读操作没有意义\",{\"1\":{\"79\":1}}],[\"因为多条\",{\"1\":{\"71\":1}}],[\"因为setnx和expire并不是原子性操作\",{\"1\":{\"69\":1}}],[\"因此需要有相应的机制将已过期的键值对删除\",{\"1\":{\"155\":1}}],[\"因此在redis恢复数据时\",{\"1\":{\"85\":1}}],[\"因此可以借助于\",{\"1\":{\"12\":1}}],[\"因此\",{\"1\":{\"9\":1,\"158\":2}}],[\"everysec\",{\"1\":{\"80\":2}}],[\"elif\",{\"1\":{\"76\":1}}],[\"else\",{\"1\":{\"71\":3,\"76\":1}}],[\"error\",{\"1\":{\"76\":1}}],[\"end\",{\"1\":{\"71\":4}}],[\"enhance\",{\"1\":{\"14\":1}}],[\"ex\",{\"1\":{\"156\":2}}],[\"ex=lock\",{\"1\":{\"71\":1}}],[\"ex=30\",{\"1\":{\"69\":1,\"70\":1}}],[\"expires\",{\"1\":{\"157\":1}}],[\"expireat\",{\"1\":{\"156\":2}}],[\"expire\",{\"1\":{\"68\":1,\"156\":1,\"159\":1}}],[\"那么当有大量这样的请求到来时\",{\"1\":{\"182\":1}}],[\"那么不管用户存放多少数据刀redis中\",{\"1\":{\"148\":1}}],[\"那么就会出现进程a删除进程b刚加的锁\",{\"1\":{\"70\":1}}],[\"那么过了一定时间后改锁也会自动释放掉\",{\"1\":{\"68\":1}}],[\"那么其他进程将永远不会获得锁出现死锁的情况\",{\"1\":{\"68\":1}}],[\"当缓存服务器宕机或不可用时\",{\"1\":{\"177\":1}}],[\"当这些缓存同时过期时\",{\"1\":{\"177\":1}}],[\"当应用程序需要读取数据时\",{\"1\":{\"172\":1}}],[\"当时间到达时\",{\"1\":{\"158\":1}}],[\"当我们查找一个key时\",{\"1\":{\"157\":1}}],[\"当我们对一个key设置过期时间时\",{\"1\":{\"157\":1}}],[\"当redis的运行内存已经超过redis设置的最大内存之后\",{\"1\":{\"147\":1}}],[\"当开启了混合持久化时\",{\"1\":{\"87\":1}}],[\"当aof文件大小超过所设定的阈值后\",{\"1\":{\"81\":1}}],[\"当命令执行成功但是还没来得及写入到硬盘的时候\",{\"1\":{\"80\":1}}],[\"当然在设置字符串时也可以同时对key设置过期时间\",{\"1\":{\"156\":1}}],[\"当然\",{\"1\":{\"80\":1,\"156\":1}}],[\"当锁的时间超过一定时间后自动释放锁\",{\"1\":{\"68\":1}}],[\"当一个工作流获得锁之后\",{\"1\":{\"66\":1}}],[\"应对缓存击穿可采取前面说到的两种方案\",{\"1\":{\"181\":1}}],[\"应用程序尝试写入数据到缓存\",{\"1\":{\"171\":1,\"172\":1}}],[\"应用程序直接访问缓存\",{\"1\":{\"171\":1}}],[\"应用程序首先将数据写入数据库\",{\"1\":{\"168\":1}}],[\"应用程序首先检查缓存以获取所需数据\",{\"1\":{\"168\":1}}],[\"应用程序将从数据源\",{\"1\":{\"168\":1}}],[\"应用场景\",{\"0\":{\"99\":1,\"103\":1,\"107\":1,\"111\":1,\"115\":1,\"119\":1,\"123\":1,\"127\":1,\"131\":1}}],[\"应用篇\",{\"0\":{\"52\":1}}],[\"应该设置一个超时时间\",{\"1\":{\"68\":1}}],[\"以避免频繁查询同一个不存在的数据\",{\"1\":{\"184\":1}}],[\"以确保即使部分节点宕机\",{\"1\":{\"178\":1}}],[\"以下是一些常见问题及解决方案\",{\"1\":{\"175\":1}}],[\"以下是一些处理方式\",{\"1\":{\"170\":1}}],[\"以下是一些关于缓存的关键点\",{\"1\":{\"166\":1}}],[\"以下是几种常见的缓存读写策略及其适用场景\",{\"1\":{\"167\":1}}],[\"以减少从较慢的存储设备\",{\"1\":{\"166\":1}}],[\"以求合理使用cpu时间和避免内存浪费之间取得平衡\",{\"1\":{\"159\":1}}],[\"以此来保障redis高效的运行\",{\"1\":{\"147\":1}}],[\"以二进制的方式写入磁盘\",{\"1\":{\"90\":1}}],[\"以上步骤只能解决锁超时自动释放\",{\"1\":{\"69\":1}}],[\"以上代码实现中如果当前进程挂了\",{\"1\":{\"68\":1}}],[\"以便下次访问时直接从缓存中获取\",{\"1\":{\"168\":1}}],[\"以便\",{\"1\":{\"9\":1}}],[\"sentinel\",{\"1\":{\"178\":1}}],[\"setex\",{\"1\":{\"76\":2,\"156\":1}}],[\"set\",{\"0\":{\"109\":1},\"1\":{\"69\":1,\"70\":1,\"71\":1,\"79\":3,\"81\":4,\"96\":1,\"149\":1,\"151\":1,\"156\":2}}],[\"setnx\",{\"1\":{\"67\":1,\"68\":1}}],[\"sds\",{\"0\":{\"136\":1}}],[\"save\",{\"1\":{\"85\":3}}],[\"size\",{\"1\":{\"81\":2}}],[\"struct\",{\"1\":{\"157\":1}}],[\"stream\",{\"0\":{\"129\":1},\"1\":{\"96\":1}}],[\"string是最基本的key\",{\"1\":{\"97\":1}}],[\"string\",{\"0\":{\"97\":1},\"1\":{\"96\":1}}],[\"str\",{\"1\":{\"71\":1}}],[\"script\",{\"1\":{\"71\":6}}],[\"sleep\",{\"1\":{\"67\":1,\"71\":1}}],[\"0及之后的版本\",{\"1\":{\"159\":1}}],[\"0版新增\",{\"1\":{\"96\":1}}],[\"0版本新增的方式\",{\"1\":{\"90\":1}}],[\"0版本之后开始提供参数\",{\"1\":{\"159\":1}}],[\"0版本之后\",{\"1\":{\"87\":1}}],[\"001\",{\"1\":{\"67\":1,\"71\":1,\"76\":1}}],[\"0\",{\"1\":{\"67\":1,\"71\":3}}],[\"此配置可通过\",{\"1\":{\"159\":1}}],[\"此时会维护一个aof\",{\"1\":{\"82\":1}}],[\"此时数据并未写入到硬盘\",{\"1\":{\"80\":1}}],[\"此时进程2可以从r1\",{\"1\":{\"72\":1}}],[\"此时进程a进行删除锁的操作\",{\"1\":{\"70\":1}}],[\"此处最好设置一个最大的循环时间\",{\"1\":{\"67\":1}}],[\"此文字有脚注^first\",{\"1\":{\"20\":1}}],[\"write\",{\"0\":{\"171\":1,\"172\":1},\"1\":{\"168\":1,\"171\":2}}],[\"watchdog的设计原则\",{\"0\":{\"73\":1}}],[\"with\",{\"1\":{\"71\":1}}],[\"will\",{\"1\":{\"28\":1}}],[\"while\",{\"1\":{\"67\":1,\"71\":1}}],[\"work\",{\"1\":{\"67\":1}}],[\"伪代码\",{\"1\":{\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1}}],[\"首先会检查缓存\",{\"1\":{\"172\":1}}],[\"首先让我们来看一下单节点分布式锁的实现\",{\"1\":{\"67\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"本文我们主要讨论redis的实现方案\",{\"1\":{\"67\":1}}],[\"本页面就是一个示例\",{\"1\":{\"3\":1}}],[\"单机可设置互斥锁\",{\"1\":{\"181\":1}}],[\"单纯查询或者删除依然可以正常工作\",{\"1\":{\"150\":1}}],[\"单节点分布式锁\",{\"0\":{\"67\":1}}],[\"单词\",{\"1\":{\"19\":1}}],[\"各个机器时钟的不一致性等问题来努力的保证上述两点锁的性质被满足\",{\"1\":{\"66\":1}}],[\"网络的不稳定性\",{\"1\":{\"66\":1}}],[\"分布式的话还得使用\",{\"1\":{\"181\":1}}],[\"分布式锁的实现有很多种\",{\"1\":{\"67\":1}}],[\"分布式锁\",{\"1\":{\"66\":1}}],[\"分别是save和bgsave\",{\"1\":{\"85\":1}}],[\"分类为\",{\"1\":{\"29\":1}}],[\"这两种策略配合使用\",{\"1\":{\"159\":1}}],[\"这两个命令的话\",{\"1\":{\"81\":1}}],[\"这两个操作是非原子性的\",{\"1\":{\"71\":1}}],[\"这八种策略大体分为\",{\"1\":{\"150\":1}}],[\"这意味着当\",{\"1\":{\"81\":1}}],[\"这意味着你可以在\",{\"1\":{\"31\":1}}],[\"这种设置在一定程度上平衡了数据的持久性和性能之间的关系\",{\"1\":{\"80\":1}}],[\"这种保存写操作命令到日志的持久化方式就是aof\",{\"1\":{\"79\":1}}],[\"这个策略通常由系统管理员根据应用需求进行配置\",{\"1\":{\"172\":1}}],[\"这个数据就会发生丢失\",{\"1\":{\"80\":1}}],[\"这个时候我们就需要在所有机器都能看见的区域来实现锁\",{\"1\":{\"66\":1}}],[\"这里的\",{\"1\":{\"79\":1}}],[\"这样才可以保证数据的最终一致性\",{\"1\":{\"170\":1}}],[\"这样可以避免内存不足而导致的redis实例崩溃\",{\"1\":{\"148\":1}}],[\"这样可以避免主线程阻塞\",{\"1\":{\"85\":1}}],[\"这样在redis重启到时候就能从磁盘上恢复数据\",{\"1\":{\"90\":1}}],[\"这样在redis重启加载数据的时候\",{\"1\":{\"87\":1}}],[\"这样减少数据丢失\",{\"1\":{\"87\":1}}],[\"这样加快加载速度\",{\"1\":{\"87\":1}}],[\"这样就减少了aof文件中命令的数量\",{\"1\":{\"81\":1}}],[\"这样就会出现冲突\",{\"1\":{\"72\":1}}],[\"这样一来一个键值对在重写日志中只用一条命令就可以了\",{\"1\":{\"81\":1}}],[\"这样做其实有两个好处\",{\"1\":{\"80\":1}}],[\"这样如果一个节点挂掉其他节点能继续工作呢\",{\"1\":{\"71\":1}}],[\"这样如果出现进程挂了\",{\"1\":{\"68\":1}}],[\"目前随着分布式处理的广泛使用\",{\"1\":{\"66\":1}}],[\"目录\",{\"0\":{\"39\":1,\"46\":1}}],[\"进行配置\",{\"1\":{\"159\":1}}],[\"进行数据淘汰\",{\"1\":{\"150\":1}}],[\"进行引用\",{\"1\":{\"30\":1}}],[\"进而发生阻塞导致后续命令无法执行\",{\"1\":{\"80\":1}}],[\"进而使其他工作流永远都无法获得锁\",{\"1\":{\"66\":1}}],[\"避免通过查询数据库来判断数据是否存在\",{\"1\":{\"184\":1}}],[\"避免大量缓存数据在同一时间过期\",{\"1\":{\"178\":1}}],[\"避免了aof在重写过程中发生失败造成现有的aof文件污染\",{\"1\":{\"81\":1}}],[\"避免了always的性能开销\",{\"1\":{\"80\":1}}],[\"避免额外的检查开销\",{\"1\":{\"80\":1}}],[\"避免持有锁的工作流因为故障无法释放锁\",{\"1\":{\"66\":1}}],[\"避免死锁\",{\"1\":{\"66\":1,\"71\":1}}],[\"同步写回\",{\"1\":{\"80\":1}}],[\"同步将aof日志数据写回到硬盘\",{\"1\":{\"80\":1}}],[\"同时将缓存数据设置为脏的\",{\"1\":{\"172\":1}}],[\"同时会记录下标\",{\"1\":{\"159\":1}}],[\"同时也能删除一部分过期数据\",{\"1\":{\"158\":1}}],[\"同时我们还得应对分布式资源环境下各个机器节点的不可靠性\",{\"1\":{\"66\":1}}],[\"同时每个页面包含\",{\"1\":{\"6\":1}}],[\"同一时刻\",{\"1\":{\"66\":1}}],[\"同一个机器的多个进程可以利用共享内存\",{\"1\":{\"66\":1}}],[\"锁的标识\",{\"1\":{\"71\":1}}],[\"锁的超时时间\",{\"1\":{\"71\":1}}],[\"锁的名称\",{\"1\":{\"71\":2}}],[\"锁代表着对公共资源的独占声明\",{\"1\":{\"66\":1}}],[\"锁\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"六\",{\"0\":{\"63\":1}}],[\"rdb\",{\"0\":{\"87\":1},\"1\":{\"88\":1}}],[\"rdb文件加载是在服务器启动时自动执行\",{\"1\":{\"85\":1}}],[\"rdb恢复数据的效率会比aof高\",{\"1\":{\"85\":1}}],[\"rdb快照如何使用\",{\"1\":{\"85\":1}}],[\"rdb快照是记录某一瞬间的内存数据\",{\"1\":{\"85\":1}}],[\"rdb快照是什么\",{\"1\":{\"85\":1}}],[\"rdb快照\",{\"0\":{\"85\":1},\"1\":{\"90\":1}}],[\"rdb持久化重启redis时恢复数据较快\",{\"1\":{\"87\":1}}],[\"rdb持久化与aof持久化的优缺点\",{\"1\":{\"87\":1}}],[\"rdb持久化\",{\"0\":{\"84\":1}}],[\"random\",{\"1\":{\"150\":2}}],[\"rate=0\",{\"1\":{\"76\":1}}],[\"ray\",{\"0\":{\"62\":1}}],[\"r5重新获得锁\",{\"1\":{\"72\":1}}],[\"r4\",{\"1\":{\"72\":1}}],[\"r3机器获得了锁\",{\"1\":{\"72\":1}}],[\"r2\",{\"1\":{\"72\":1}}],[\"read\",{\"0\":{\"171\":1},\"1\":{\"168\":1,\"171\":3}}],[\"rewrite\",{\"1\":{\"81\":4}}],[\"redlock采用的是法团准则方案\",{\"1\":{\"72\":1}}],[\"redlock的核心思想就是使用多个redis冗余实例来避免单redis的不可靠性\",{\"1\":{\"72\":1}}],[\"redlock\",{\"0\":{\"72\":1}}],[\"redis高可用篇\",{\"0\":{\"191\":1}}],[\"redis常见面试题\",{\"0\":{\"188\":1}}],[\"redis面试篇\",{\"0\":{\"186\":1}}],[\"redis缓存篇\",{\"0\":{\"162\":1}}],[\"redis在访问或者修改key之前都会调用expireifneeded函数对其进行检查\",{\"1\":{\"159\":1}}],[\"redis选择\",{\"1\":{\"159\":1}}],[\"redis首先会检查该key是否存在于过期字典中\",{\"1\":{\"157\":1}}],[\"redisdb\",{\"1\":{\"157\":3}}],[\"redis会把该key带上过期时间存储到一个过期字典中\",{\"1\":{\"157\":1}}],[\"redis过期删除策略\",{\"0\":{\"155\":1},\"1\":{\"153\":1,\"160\":1}}],[\"redis如何管理热数据\",{\"1\":{\"152\":1}}],[\"redis的过期删除策略是什么\",{\"0\":{\"159\":1}}],[\"redis的内存淘汰策略有哪些\",{\"0\":{\"150\":1}}],[\"redis的快照是全量快照\",{\"1\":{\"85\":1}}],[\"redis也不会对可用内存进行检查\",{\"1\":{\"148\":1}}],[\"redis默认最大运行内存\",{\"0\":{\"148\":1}}],[\"redis内存淘汰策略共有八种\",{\"1\":{\"150\":1}}],[\"redis内存淘汰策略\",{\"0\":{\"147\":1}}],[\"redis策略篇\",{\"0\":{\"145\":1}}],[\"redis键值对数据库是如何实现的\",{\"0\":{\"135\":1}}],[\"redis数据结构\",{\"0\":{\"134\":1}}],[\"redis数据类型及应用场景\",{\"0\":{\"96\":1}}],[\"redis数据类型篇\",{\"0\":{\"94\":1}}],[\"redis4\",{\"1\":{\"90\":1}}],[\"redis实现了持久化机制\",{\"1\":{\"90\":1}}],[\"redis是如何实现定时删除的\",{\"1\":{\"159\":1}}],[\"redis是如何实现惰性删除的\",{\"1\":{\"159\":1}}],[\"redis是可以对key设置过期时间的\",{\"1\":{\"155\":1}}],[\"redis是基于内存进行读写操作的\",{\"1\":{\"90\":1}}],[\"redis是先执行命令再将该命令写入到aof文件中\",{\"1\":{\"80\":1}}],[\"redis持久化篇\",{\"0\":{\"90\":1}}],[\"redis中的缓冲区了解吗\",{\"0\":{\"190\":1},\"1\":{\"88\":1}}],[\"redis还可以通过修改配置文件选项来实现每隔一段时间自动执行一次bgsave命令\",{\"1\":{\"85\":1}}],[\"redis并未提供专门用于加载rdb文件的命令\",{\"1\":{\"85\":1}}],[\"redis提供了两个命令来生成rdb文件\",{\"1\":{\"85\":1}}],[\"redis提供了3种写回硬盘的策略\",{\"1\":{\"80\":1}}],[\"redis就会启动重写机制来压缩aof文件\",{\"1\":{\"81\":1}}],[\"redis为避免这种情况提供了aof重写\",{\"1\":{\"81\":1}}],[\"redis执行完写操作命令后\",{\"1\":{\"80\":1}}],[\"redis写入aof日志的过程大体如下\",{\"1\":{\"80\":1}}],[\"redis分布式锁\",{\"0\":{\"65\":1}}],[\"redis应用篇\",{\"0\":{\"63\":1}}],[\"redis\",{\"1\":{\"67\":2,\"68\":2,\"69\":1,\"70\":1,\"71\":8,\"73\":1,\"76\":3,\"81\":2,\"87\":1,\"149\":4,\"151\":5,\"159\":5,\"160\":1,\"173\":1,\"178\":1},\"2\":{\"54\":1,\"64\":1,\"74\":1,\"77\":1,\"83\":1,\"89\":1,\"91\":1,\"93\":1,\"95\":1,\"133\":1,\"144\":1,\"146\":1,\"154\":1,\"161\":1,\"163\":1,\"165\":1,\"174\":1,\"185\":1,\"187\":1,\"189\":1,\"192\":1,\"194\":1,\"196\":1,\"198\":1}}],[\"redis学习笔记\",{\"0\":{\"45\":1}}],[\"result\",{\"1\":{\"71\":2}}],[\"register\",{\"1\":{\"71\":2}}],[\"regarded\",{\"1\":{\"28\":1}}],[\"release\",{\"1\":{\"71\":2}}],[\"return\",{\"1\":{\"67\":1,\"68\":2,\"69\":1,\"70\":1,\"71\":11,\"76\":3}}],[\"详情\",{\"0\":{\"57\":1,\"61\":1}}],[\"详情容器\",{\"1\":{\"15\":1}}],[\"功能详情\",{\"1\":{\"58\":1,\"62\":1}}],[\"功能\",{\"0\":{\"55\":1,\"59\":1},\"1\":{\"56\":1,\"60\":1}}],[\"功能亮点\",{\"0\":{\"35\":1}}],[\"面试篇\",{\"0\":{\"53\":1}}],[\"buffer\",{\"1\":{\"172\":1}}],[\"buf缓冲区到数据写入到aof文件\",{\"1\":{\"80\":1}}],[\"buf缓冲区\",{\"1\":{\"80\":1}}],[\"bitmap\",{\"0\":{\"117\":1},\"1\":{\"96\":1}}],[\"bloom\",{\"1\":{\"76\":4}}],[\"bloomfilter\",{\"1\":{\"76\":2}}],[\"back\",{\"0\":{\"172\":1}}],[\"baz\",{\"0\":{\"58\":1}}],[\"bar\",{\"0\":{\"36\":1,\"55\":1},\"1\":{\"56\":1}}],[\"behind\",{\"0\":{\"172\":1}}],[\"be\",{\"1\":{\"28\":1}}],[\"+1\",{\"1\":{\"72\":2}}],[\"+\",{\"1\":{\"31\":1,\"71\":1,\"159\":1}}],[\"图片引入\",{\"1\":{\"30\":1}}],[\"图片增强\",{\"0\":{\"23\":1}}],[\"日\",{\"1\":{\"29\":1}}],[\"月\",{\"1\":{\"29\":1}}],[\"年\",{\"1\":{\"29\":1}}],[\"作者设置为\",{\"1\":{\"29\":1}}],[\"pool机制就是采用这种模式\",{\"1\":{\"172\":1}}],[\"policy\",{\"1\":{\"151\":2}}],[\"policy查看当前内存淘汰策略\",{\"1\":{\"150\":1}}],[\"pttl\",{\"1\":{\"156\":1}}],[\"px\",{\"1\":{\"156\":1}}],[\"persist\",{\"1\":{\"156\":1}}],[\"percentage\",{\"1\":{\"81\":2}}],[\"pexpire\",{\"1\":{\"156\":1}}],[\"pybloom\",{\"1\":{\"76\":1}}],[\"python\",{\"1\":{\"73\":1,\"76\":1},\"2\":{\"41\":1}}],[\"pattern\",{\"1\":{\"170\":1}}],[\"pattern下\",{\"0\":{\"169\":1,\"170\":1}}],[\"param\",{\"1\":{\"71\":7}}],[\"pass\",{\"1\":{\"67\":1}}],[\"page\",{\"1\":{\"28\":1}}],[\"public\",{\"1\":{\"30\":1}}],[\"plugin\",{\"1\":{\"14\":1}}],[\"hz\",{\"1\":{\"159\":1}}],[\"hyperloglog\",{\"0\":{\"121\":1},\"1\":{\"96\":1}}],[\"hash\",{\"0\":{\"105\":1},\"1\":{\"96\":1}}],[\"hope\",{\"1\":{\"29\":1}}],[\"h1\",{\"1\":{\"28\":2}}],[\"h2o\",{\"1\":{\"17\":1}}],[\"free\",{\"1\":{\"160\":1}}],[\"from\",{\"1\":{\"76\":2}}],[\"frontmatter\",{\"1\":{\"3\":1,\"6\":1,\"11\":3,\"28\":1,\"29\":1}}],[\"found\",{\"1\":{\"199\":1}}],[\"fork出来的重写子进程会先将与主进程共享的内存数据以rdb方式写入到aof文件\",{\"1\":{\"87\":1}}],[\"foo\",{\"0\":{\"37\":1,\"59\":1},\"1\":{\"60\":1}}],[\"fetch\",{\"1\":{\"76\":1}}],[\"f\",{\"1\":{\"71\":2}}],[\"false\",{\"1\":{\"68\":1,\"71\":2}}],[\"file\",{\"1\":{\"79\":1}}],[\"filter\",{\"1\":{\"76\":1}}],[\"finally\",{\"1\":{\"67\":1}}],[\"first\",{\"1\":{\"28\":1}}],[\"through\",{\"0\":{\"171\":1},\"1\":{\"171\":5}}],[\"then\",{\"1\":{\"71\":2}}],[\"the\",{\"1\":{\"28\":1}}],[\"typedef\",{\"1\":{\"157\":1}}],[\"ttl\",{\"1\":{\"150\":1,\"156\":1}}],[\"timeout=2\",{\"1\":{\"71\":1}}],[\"timeout=3\",{\"1\":{\"71\":1}}],[\"timeout\",{\"1\":{\"71\":7}}],[\"time\",{\"1\":{\"67\":1,\"71\":6}}],[\"title\",{\"1\":{\"28\":3}}],[\"to\",{\"1\":{\"76\":1}}],[\"todo\",{\"1\":{\"67\":1}}],[\"toc\",{\"1\":{\"6\":1}}],[\"true\",{\"1\":{\"67\":1,\"68\":1,\"69\":1,\"71\":1}}],[\"try\",{\"1\":{\"67\":1}}],[\"组件\",{\"0\":{\"24\":1,\"31\":1},\"1\":{\"31\":1}}],[\"25ms\",{\"1\":{\"159\":1}}],[\"25\",{\"1\":{\"159\":2}}],[\"20\",{\"1\":{\"159\":3}}],[\"2020\",{\"1\":{\"29\":1}}],[\"2则表示key不存在\",{\"1\":{\"156\":1}}],[\"2版新增\",{\"1\":{\"96\":2}}],[\"2\",{\"1\":{\"22\":1,\"69\":1,\"71\":1,\"72\":2,\"80\":1,\"96\":2,\"168\":1,\"171\":1,\"172\":1}}],[\"计划\",{\"1\":{\"22\":2}}],[\"x\",{\"1\":{\"22\":1}}],[\"任务列表\",{\"0\":{\"22\":1}}],[\"标签为\",{\"1\":{\"29\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"28\":1}}],[\"标题和页面信息\",{\"1\":{\"6\":1}}],[\"标记\",{\"0\":{\"21\":1}}],[\"的数量\",{\"1\":{\"159\":3}}],[\"的配置文件\",{\"1\":{\"159\":1}}],[\"的时间复杂度来快速查找\",{\"1\":{\"157\":1}}],[\"的值默认为\",{\"1\":{\"81\":2}}],[\"的\",{\"1\":{\"19\":1,\"28\":1,\"29\":1}}],[\"is\",{\"1\":{\"76\":2}}],[\"import\",{\"1\":{\"71\":3,\"76\":1}}],[\"if\",{\"1\":{\"67\":1,\"68\":1,\"71\":4,\"76\":3}}],[\"i\",{\"1\":{\"31\":1}}],[\"innodb\",{\"1\":{\"172\":1}}],[\"int\",{\"1\":{\"71\":1}}],[\"in\",{\"1\":{\"28\":1,\"76\":1}}],[\"identifier\",{\"1\":{\"70\":2,\"71\":8}}],[\"id\",{\"1\":{\"19\":1}}],[\"it\",{\"1\":{\"12\":2}}],[\"我们一般有三种策略\",{\"1\":{\"158\":1}}],[\"我们可以发现受r1挂了重启影响的只有在r1挂了的时刻在r1上存到锁\",{\"1\":{\"72\":1}}],[\"我们可以通过lua\",{\"1\":{\"71\":1}}],[\"我们就要考虑读写的一致性问题\",{\"1\":{\"72\":1}}],[\"我们就要承受单节点带来的风险\",{\"1\":{\"71\":1}}],[\"我们能不能多启动几个redis\",{\"1\":{\"71\":1}}],[\"我们应该将加锁和设置超时时间做到原子化\",{\"1\":{\"69\":1}}],[\"我们很多时候需要协调位于不同机器上的不同进程对共享资源的独占使用\",{\"1\":{\"66\":1}}],[\"我们支持\",{\"1\":{\"56\":1,\"60\":1}}],[\"我在右对齐\",{\"1\":{\"18\":1}}],[\"我是居中的\",{\"1\":{\"18\":1}}],[\"自定义对齐\",{\"0\":{\"18\":1}}],[\"自定义标题\",{\"1\":{\"15\":5}}],[\"上诉内容中\",{\"1\":{\"79\":1}}],[\"上下角标\",{\"0\":{\"17\":1}}],[\"上一篇\",{\"1\":{\"3\":1}}],[\"危险容器\",{\"1\":{\"15\":1}}],[\"警告容器\",{\"1\":{\"15\":1}}],[\"1的数据或者id特别大不存在的数据\",{\"1\":{\"183\":1}}],[\"1则表示永不超时\",{\"1\":{\"156\":1}}],[\"1704038400000表示设置key在时间1704038400000\",{\"1\":{\"156\":1}}],[\"1704038400表示设置key在时间戳1704038400\",{\"1\":{\"156\":1}}],[\"1gb\",{\"1\":{\"149\":1}}],[\"10\",{\"1\":{\"85\":1,\"159\":1}}],[\"100表示设置key在100毫秒后过期\",{\"1\":{\"156\":1}}],[\"100表示设置key在100秒之后过期\",{\"1\":{\"156\":1}}],[\"10000\",{\"1\":{\"85\":1}}],[\"100\",{\"1\":{\"81\":2}}],[\"12之后的版本可以使用set并设置超时时间和非空判断\",{\"1\":{\"69\":1}}],[\"19th\",{\"1\":{\"17\":1}}],[\"1\",{\"1\":{\"15\":1,\"22\":1,\"29\":2,\"31\":2,\"71\":6,\"80\":1,\"85\":1,\"157\":1,\"159\":1,\"168\":1,\"171\":1,\"172\":1}}],[\"==\",{\"1\":{\"71\":2,\"76\":1}}],[\"=\",{\"1\":{\"15\":1,\"71\":10,\"76\":3}}],[\"allkeys\",{\"1\":{\"150\":3}}],[\"always\",{\"1\":{\"80\":2}}],[\"auto\",{\"1\":{\"81\":4}}],[\"appendonly\",{\"1\":{\"79\":1}}],[\"appendfilename参数去指定aof持久化文件的名称\",{\"1\":{\"79\":1}}],[\"append\",{\"1\":{\"79\":1}}],[\"aof文件可以保存rdb格式吗\",{\"0\":{\"87\":1}}],[\"aof文件中则会写下如下内容\",{\"1\":{\"79\":1}}],[\"aof后台重写\",{\"0\":{\"82\":1}}],[\"aof重写机制是在重写时\",{\"1\":{\"81\":1}}],[\"aof重写机制\",{\"0\":{\"81\":1}}],[\"aof写回策略\",{\"0\":{\"80\":1}}],[\"aof\",{\"0\":{\"87\":1},\"1\":{\"79\":1,\"80\":1,\"81\":10,\"87\":1,\"88\":1}}],[\"aof日志文件过大时就会带来性能问题\",{\"1\":{\"81\":1}}],[\"aof日志文件越来越大\",{\"1\":{\"81\":1}}],[\"aof日志文件其实就是普通文本\",{\"1\":{\"79\":1}}],[\"aof日志文件内容\",{\"1\":{\"79\":1}}],[\"aof日志\",{\"0\":{\"79\":1},\"1\":{\"90\":1}}],[\"aof持久化机器宕机时丢失数据少\",{\"1\":{\"87\":1}}],[\"aof持久化功能默认是不开启的\",{\"1\":{\"79\":1}}],[\"aof持久化\",{\"0\":{\"78\":1}}],[\"add\",{\"1\":{\"76\":2}}],[\"acquire\",{\"1\":{\"71\":4}}],[\"args=\",{\"1\":{\"71\":2}}],[\"argv\",{\"1\":{\"71\":2}}],[\"aside\",{\"0\":{\"168\":1,\"169\":1,\"170\":1},\"1\":{\"168\":3,\"170\":1,\"171\":2}}],[\"as\",{\"1\":{\"28\":1}}],[\"attrs\",{\"0\":{\"19\":1}}],[\"a\",{\"1\":{\"15\":1}}],[\"与\",{\"1\":{\"15\":1}}],[\"包含\",{\"1\":{\"15\":1}}],[\"信息容器\",{\"1\":{\"15\":1}}],[\"volatile\",{\"1\":{\"150\":4}}],[\"value最多可容纳的数据长度为512m\",{\"1\":{\"97\":1}}],[\"value是具体的值\",{\"1\":{\"97\":1}}],[\"value结构\",{\"1\":{\"97\":1}}],[\"value键值对\",{\"1\":{\"81\":1}}],[\"value2\",{\"1\":{\"81\":2}}],[\"value1\",{\"1\":{\"79\":1,\"81\":2}}],[\"value1命令\",{\"1\":{\"79\":1}}],[\"value\",{\"1\":{\"76\":7}}],[\"variable\",{\"1\":{\"15\":1}}],[\"vue\",{\"1\":{\"31\":2}}],[\"vuepress\",{\"0\":{\"13\":1},\"1\":{\"9\":2,\"11\":2,\"12\":1,\"13\":2,\"14\":1,\"30\":1}}],[\"安全的在\",{\"1\":{\"15\":1}}],[\"提出了混合使用aof日志和rdb快照\",{\"1\":{\"87\":1}}],[\"提供了一定的数据安全性保障同时在一定程度上减少了磁盘同步操作对性能的影响\",{\"1\":{\"80\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"14\":1}}],[\"提示容器\",{\"0\":{\"15\":1},\"1\":{\"15\":1}}],[\"min\",{\"1\":{\"81\":2}}],[\"maxmemory\",{\"1\":{\"149\":1,\"150\":1,\"151\":2}}],[\"maxmemory的默认值是3g\",{\"1\":{\"148\":1}}],[\"maxmemory的默认值是0\",{\"1\":{\"148\":1}}],[\"maxmemory的默认值是不同的\",{\"1\":{\"148\":1}}],[\"math\",{\"1\":{\"71\":2}}],[\"markdown\",{\"0\":{\"9\":1,\"10\":1,\"11\":1,\"12\":1},\"1\":{\"9\":2,\"10\":3,\"11\":1,\"12\":3,\"13\":2,\"14\":1,\"15\":1,\"28\":3,\"29\":1,\"30\":2,\"31\":2},\"2\":{\"26\":1}}],[\"mysql\",{\"2\":{\"44\":1}}],[\"mysql学习笔记\",{\"0\":{\"43\":1}}],[\"ms\",{\"1\":{\"29\":1}}],[\"more\",{\"1\":{\"27\":1}}],[\"md\",{\"1\":{\"14\":1}}],[\"请使用绝对链接\",{\"1\":{\"30\":1}}],[\"请阅读\",{\"1\":{\"13\":1}}],[\"请先阅读\",{\"1\":{\"10\":1}}],[\"关于这些扩展\",{\"1\":{\"13\":1}}],[\"语法\",{\"1\":{\"14\":1,\"31\":1}}],[\"语法进行了扩展\",{\"1\":{\"13\":1}}],[\"语法扩展\",{\"1\":{\"12\":1}}],[\"对ip进行限流\",{\"1\":{\"184\":1}}],[\"对请求的参数进行合理性校验\",{\"1\":{\"184\":1}}],[\"对一些非常热点的数据\",{\"1\":{\"178\":1,\"181\":1}}],[\"对cpu不友好\",{\"1\":{\"158\":1}}],[\"对数据库进行了至少10次修改就会执行bgsave\",{\"1\":{\"85\":1}}],[\"对数据库进行了至少1次修改就会执行bgsave\",{\"1\":{\"85\":1}}],[\"对于查询数据库后确认不存在的数据\",{\"1\":{\"184\":1}}],[\"对于\",{\"1\":{\"30\":1}}],[\"对\",{\"1\":{\"13\":1}}],[\"为此增加了定期删除循环流程的时间上限\",{\"1\":{\"159\":1}}],[\"为了避免这种情况\",{\"1\":{\"159\":1}}],[\"为了保证定期删除不会出现循环过度\",{\"1\":{\"159\":1}}],[\"为了保证数据不丢失\",{\"1\":{\"90\":1}}],[\"为了解决这个问题redis作者提出了延迟重启的解决方案\",{\"1\":{\"72\":1}}],[\"为了丰富文档写作\",{\"1\":{\"13\":1}}],[\"为每个\",{\"1\":{\"11\":1}}],[\"插件来实现\",{\"1\":{\"12\":1}}],[\"扩展\",{\"0\":{\"12\":1,\"13\":1},\"1\":{\"13\":1}}],[\"中读取数据\",{\"1\":{\"168\":1}}],[\"中\",{\"1\":{\"159\":1,\"166\":1}}],[\"中设置页面信息\",{\"1\":{\"29\":1}}],[\"中设置页面标题\",{\"1\":{\"28\":1}}],[\"中使用\",{\"1\":{\"15\":1,\"31\":1}}],[\"中的第一个\",{\"1\":{\"28\":1}}],[\"中的\",{\"1\":{\"13\":1}}],[\"中很重要的一个概念\",{\"1\":{\"11\":1}}],[\"中自定义它们\",{\"1\":{\"6\":1}}],[\"是先更新数据库\",{\"1\":{\"170\":1}}],[\"是一种高效的数据存储技术\",{\"1\":{\"166\":1}}],[\"是否过期\",{\"1\":{\"159\":1}}],[\"是为了解决多个工作流对共享资源的访问出现冲突\",{\"1\":{\"66\":1}}],[\"是\",{\"1\":{\"11\":1}}],[\"通过加锁机制来控制只有一个线程去加载数据和更新缓存\",{\"1\":{\"178\":1}}],[\"通过限制执行时长和执行频率来减少删除操作对cpu对影响\",{\"1\":{\"158\":1}}],[\"通过修改\",{\"1\":{\"151\":1}}],[\"通过\",{\"1\":{\"11\":1,\"14\":1,\"149\":1,\"151\":1}}],[\"配置键为\",{\"1\":{\"159\":1}}],[\"配置文件修改\",{\"1\":{\"151\":1}}],[\"配置\",{\"0\":{\"11\":1}}],[\"演示\",{\"1\":{\"10\":1}}],[\"和\",{\"0\":{\"87\":1},\"1\":{\"10\":1,\"29\":1,\"81\":2,\"150\":1}}],[\"还不会编写\",{\"1\":{\"10\":1}}],[\"介绍\",{\"0\":{\"10\":1,\"56\":1,\"60\":1},\"1\":{\"10\":1,\"11\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"31\":1}}],[\"你需要阅读\",{\"1\":{\"11\":1}}],[\"你应该创建和编写\",{\"1\":{\"9\":1}}],[\"你可以认为缓存击穿是缓存雪崩的一个子集\",{\"1\":{\"181\":1}}],[\"你可以将图片和\",{\"1\":{\"30\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"30\":1}}],[\"你可以在\",{\"1\":{\"28\":1,\"29\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"6\":1}}],[\"你可以标记\",{\"1\":{\"21\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"9\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"3\":1}}],[\"文件可以保存\",{\"1\":{\"88\":1}}],[\"文件的大小超过\",{\"1\":{\"81\":1}}],[\"文件的大小达到上一次重写后的大小的\",{\"1\":{\"81\":1}}],[\"文件大小超过\",{\"1\":{\"81\":1}}],[\"文件夹的图片\",{\"1\":{\"30\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"30\":1}}],[\"文件\",{\"1\":{\"9\":1}}],[\"文件生成页面\",{\"1\":{\"9\":1}}],[\"文章标题列表\",{\"1\":{\"6\":1}}],[\"展示\",{\"0\":{\"9\":1}}],[\"打印按钮\",{\"1\":{\"6\":1}}],[\"夜间模式按钮\",{\"1\":{\"6\":1}}],[\"主从模式\",{\"0\":{\"193\":1}}],[\"主线程处理的操作命令都会被记录在重写缓冲区\",{\"1\":{\"87\":1}}],[\"主线程\",{\"1\":{\"85\":1}}],[\"主进程需要执行以下三步\",{\"1\":{\"82\":1}}],[\"主题扩展了更多\",{\"1\":{\"14\":1}}],[\"主题扩展\",{\"0\":{\"14\":1}}],[\"主题也带有以下元素\",{\"1\":{\"6\":1}}],[\"主要从\",{\"1\":{\"9\":1}}],[\"主要功能与配置演示\",{\"0\":{\"1\":1}}],[\"禁用\",{\"2\":{\"5\":1}}],[\"禁用了如下功能\",{\"1\":{\"3\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"31\":1}}],[\"页面内容\",{\"0\":{\"30\":1}}],[\"页面标题\",{\"0\":{\"28\":1},\"1\":{\"28\":1}}],[\"页面配置\",{\"0\":{\"27\":1},\"1\":{\"29\":1},\"2\":{\"33\":1}}],[\"页面引入配置\",{\"1\":{\"11\":1}}],[\"页面信息\",{\"0\":{\"29\":1},\"1\":{\"3\":1}}],[\"页脚\",{\"1\":{\"3\":1,\"6\":1}}],[\"评论\",{\"1\":{\"3\":1,\"6\":1}}],[\"编辑此页链接\",{\"1\":{\"3\":1}}],[\"贡献者\",{\"1\":{\"3\":1,\"6\":1}}],[\"路径导航\",{\"1\":{\"3\":1,\"6\":1}}],[\"侧边栏\",{\"1\":{\"3\":1,\"6\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
