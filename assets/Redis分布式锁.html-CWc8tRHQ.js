import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as i,d as n,f as s,b as e,e as l}from"./app-DWz5k_-z.js";const c={},u=l(`<h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h2><p>锁(lock)是为了解决多个工作流对共享资源的访问出现冲突，锁代表着对公共资源的独占声明，当一个工作流获得锁之后，其他的工作流应当能看到这个资源已经被占用。<strong>所以锁的声明和释放一定要基于各个工作流的可见区域来实现</strong>。</p><p>具体实现方式很多，例如一个进程中的多线程可以利用全局变量在实现；同一个机器的多个进程可以利用共享内存，或者用一个数据库甚至使用一个文件来实现，但是不管怎么实现都要保证如下几点：</p><ul><li>互斥性：同一时刻，一个锁只能被一个工作流持有</li><li>避免死锁：避免持有锁的工作流因为故障无法释放锁，进而使其他工作流永远都无法获得锁</li></ul><p>目前随着分布式处理的广泛使用，我们很多时候需要协调位于不同机器上的不同进程对共享资源的独占使用，<strong>这个时候我们就需要在所有机器都能看见的区域来实现锁（分布式锁）</strong>，同时我们还得应对分布式资源环境下各个机器节点的不可靠性、网络的不稳定性、各个机器时钟的不一致性等问题来努力的保证上述两点锁的性质被满足。</p><h2 id="单节点分布式锁" tabindex="-1"><a class="header-anchor" href="#单节点分布式锁"><span>单节点分布式锁</span></a></h2><p>分布式锁的实现有很多种，本文我们主要讨论Redis的实现方案。</p><p>首先让我们来看一下单节点分布式锁的实现：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 伪代码</span>
<span class="token keyword">def</span> <span class="token function">work</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 此处最好设置一个最大的循环时间，如果超出循环时间则自动结束</span>
            <span class="token keyword">if</span> lock<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># todo</span>
                <span class="token keyword">pass</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span>

    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        unlock<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">lock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span>


<span class="token keyword">def</span> <span class="token function">unlock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    redis<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="给锁加超时时间" tabindex="-1"><a class="header-anchor" href="#给锁加超时时间"><span>给锁加超时时间</span></a></h3><p>以上代码实现中如果当前进程挂了，由于当前进程没有释放锁，那么其他进程将永远不会获得锁出现死锁的情况。所以我们不能单单依赖进程自己去释放锁，应该设置一个超时时间，当锁的时间超过一定时间后自动释放锁。这样如果出现进程挂了，那么过了一定时间后改锁也会自动释放掉。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 伪代码</span>
<span class="token keyword">def</span> <span class="token function">lock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> redis<span class="token punctuation">.</span>setnx<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        redis<span class="token punctuation">.</span>expire<span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用加参数的set" tabindex="-1"><a class="header-anchor" href="#使用加参数的set"><span>使用加参数的set</span></a></h3><p>以上步骤只能解决锁超时自动释放，因为setnx和expire并不是原子性操作，在加锁后进程挂掉依然会出现死锁的问题，我们应该将加锁和设置超时时间做到原子化。在Redis 2.6.12之后的版本可以使用set并设置超时时间和非空判断。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 伪代码</span>
<span class="token keyword">def</span> <span class="token function">lock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> ex<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> nx<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="给锁添加唯一标识" tabindex="-1"><a class="header-anchor" href="#给锁添加唯一标识"><span>给锁添加唯一标识</span></a></h3><p>如果进程A在持有锁的时间内未完成任务，在进程B加锁后进程A才完成任务，此时进程A进行删除锁的操作，那么就会出现进程A删除进程B刚加的锁，出现误删。所以我们在加锁的时间为每一个锁添加一个唯一标识以确保不会出现误删的情况</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 伪代码</span>
<span class="token keyword">def</span> <span class="token function">lock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> ex<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> nx<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="删除锁-原子性操作" tabindex="-1"><a class="header-anchor" href="#删除锁-原子性操作"><span>删除锁 原子性操作</span></a></h3><p>在删除锁的时间需要先判断再删除，这两个操作是非原子性的，我们可以通过Lua 脚本来执行判断和删除的操作，因为多条 Lua 命令可以保证原子性，也可以考虑事务实现。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># 伪代码</span>
<span class="token keyword">def</span> <span class="token function">release_lock</span><span class="token punctuation">(</span>lock_name<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    unlock_script <span class="token operator">=</span> <span class="token triple-quoted-string string">&quot;&quot;&quot;
    if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
        return redis.call(&quot;del&quot;,KEYS[1])
    else
        return 0
    end
    &quot;&quot;&quot;</span>
    unlock <span class="token operator">=</span> redis<span class="token punctuation">.</span>register_script<span class="token punctuation">(</span>unlock_script<span class="token punctuation">)</span>
    <span class="token keyword">return</span> unlock<span class="token punctuation">(</span>keys<span class="token operator">=</span><span class="token punctuation">[</span>lock_name<span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>identifier<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此，基于Redis实现单节点分布式锁基本完成。</p><p>最终完成版：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> uuid
<span class="token keyword">import</span> math
<span class="token keyword">import</span> time


<span class="token keyword">def</span> <span class="token function">acquire_lock_with_timeout</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lock_name<span class="token punctuation">,</span> acquire_timeout<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> lock_timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    基于 Redis 实现的分布式锁
    
    :param conn: Redis 连接
    :param lock_name: 锁的名称
    :param acquire_timeout: 获取锁的超时时间，默认 3 秒
    :param lock_timeout: 锁的超时时间，默认 2 秒
    :return:
    &quot;&quot;&quot;</span>

    identifier <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    lockname <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f&#39;lock:</span><span class="token interpolation"><span class="token punctuation">{</span>lock_name<span class="token punctuation">}</span></span><span class="token string">&#39;</span></span>
    lock_timeout <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>lock_timeout<span class="token punctuation">)</span><span class="token punctuation">)</span>

    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> acquire_timeout

    <span class="token keyword">while</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>
        <span class="token comment"># 如果不存在这个锁则加锁并设置过期时间，避免死锁</span>
        <span class="token keyword">if</span> conn<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>lockname<span class="token punctuation">,</span> identifier<span class="token punctuation">,</span> ex<span class="token operator">=</span>lock_timeout<span class="token punctuation">,</span> nx<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> identifier

        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token boolean">False</span>


<span class="token keyword">def</span> <span class="token function">release_lock</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> lock_name<span class="token punctuation">,</span> identifier<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;
    释放锁
    
    :param conn: Redis 连接
    :param lockname: 锁的名称
    :param identifier: 锁的标识
    :return:
    &quot;&quot;&quot;</span>
    unlock_script <span class="token operator">=</span> <span class="token triple-quoted-string string">&quot;&quot;&quot;
    if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
        return redis.call(&quot;del&quot;,KEYS[1])
    else
        return 0
    end
    &quot;&quot;&quot;</span>
    lockname <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f&#39;lock:</span><span class="token interpolation"><span class="token punctuation">{</span>lock_name<span class="token punctuation">}</span></span><span class="token string">&#39;</span></span>
    unlock <span class="token operator">=</span> conn<span class="token punctuation">.</span>register_script<span class="token punctuation">(</span>unlock_script<span class="token punctuation">)</span>
    result <span class="token operator">=</span> unlock<span class="token punctuation">(</span>keys<span class="token operator">=</span><span class="token punctuation">[</span>lockname<span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>identifier<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> result<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,24),r={href:"https://redis.io/topics/distlock/#the-redlock-algorithm",target:"_blank",rel:"noopener noreferrer"},d=n("h2",{id:"redlock",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#redlock"},[n("span",null,"Redlock")])],-1),k=n("p",null,"redlock的核心思想就是使用多个Redis冗余实例来避免单Redis的不可靠性。如果使用多个Redis，我们就要考虑读写的一致性问题，Redlock采用的是法团准则方案，即写入(N/2 +1)个节点后才成功，获得至少(N/2 +1)个服务器的锁则认为获得锁成功。",-1),v=n("p",null,"假设我们有五台机器，如果进程1从R1、R2、R3机器获得了锁，然后R1机器未将数据持久化到磁盘出现宕机，之后再次重启，此时进程2可以从R1、R4、R5重新获得锁（满足法团准则），这样就会出现冲突。为了解决这个问题Redis作者提出了延迟重启的解决方案。",-1),m=n("p",null,[n("strong",null,"延迟重启")],-1),b=n("p",null,"我们可以发现受R1挂了重启影响的只有在R1挂了的时刻在R1上存到锁，之后的创建的或者没在R1上存储的锁都不会受到影响",-1),h=n("h2",{id:"watchdog的设计原则",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#watchdog的设计原则"},[n("span",null,"Watchdog的设计原则")])],-1),_=n("p",null,"参考链接：",-1),g={href:"https://zhuanlan.zhihu.com/p/100140241",target:"_blank",rel:"noopener noreferrer"},y={href:"https://www.cnblogs.com/xiaoxiaotank/p/14982602.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zhuanlan.zhihu.com/p/112016634",target:"_blank",rel:"noopener noreferrer"};function w(R,q){const a=p("ExternalLinkIcon");return o(),i("div",null,[u,n("p",null,[s("如果依赖单节点，我们就要承受单节点带来的风险，我们能不能多启动几个Redis，保留键的副本，这样如果一个节点挂掉其他节点能继续工作呢？如果锁超时了我们如何给锁续期以及如何避免锁的无限续期。下面我们将试着讨论"),n("a",r,[s("Redlock"),e(a)]),s("。")]),d,k,v,m,b,h,_,n("blockquote",null,[n("p",null,[n("a",g,[s("基于Redis的分布式锁详解"),e(a)])]),n("p",null,[n("a",y,[s("基于Redis的分布式锁设计"),e(a)])]),n("p",null,[n("a",f,[s("Python 使用 Redis 实现分布式锁"),e(a)])])])])}const A=t(c,[["render",w],["__file","Redis分布式锁.html.vue"]]),B=JSON.parse('{"path":"/redis/%E5%BA%94%E7%94%A8%E7%AF%87/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"Redis分布式锁","lang":"zh-CN","frontmatter":{"title":"Redis分布式锁","order":2,"category":["Redis"],"description":"锁 锁(lock)是为了解决多个工作流对共享资源的访问出现冲突，锁代表着对公共资源的独占声明，当一个工作流获得锁之后，其他的工作流应当能看到这个资源已经被占用。所以锁的声明和释放一定要基于各个工作流的可见区域来实现。 具体实现方式很多，例如一个进程中的多线程可以利用全局变量在实现；同一个机器的多个进程可以利用共享内存，或者用一个数据库甚至使用一个文件来...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/blogs/redis/%E5%BA%94%E7%94%A8%E7%AF%87/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"皮卡丘"}],["meta",{"property":"og:title","content":"Redis分布式锁"}],["meta",{"property":"og:description","content":"锁 锁(lock)是为了解决多个工作流对共享资源的访问出现冲突，锁代表着对公共资源的独占声明，当一个工作流获得锁之后，其他的工作流应当能看到这个资源已经被占用。所以锁的声明和释放一定要基于各个工作流的可见区域来实现。 具体实现方式很多，例如一个进程中的多线程可以利用全局变量在实现；同一个机器的多个进程可以利用共享内存，或者用一个数据库甚至使用一个文件来..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"皮卡丘"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis分布式锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"皮卡丘\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[]},{"level":2,"title":"单节点分布式锁","slug":"单节点分布式锁","link":"#单节点分布式锁","children":[{"level":3,"title":"给锁加超时时间","slug":"给锁加超时时间","link":"#给锁加超时时间","children":[]},{"level":3,"title":"使用加参数的set","slug":"使用加参数的set","link":"#使用加参数的set","children":[]},{"level":3,"title":"给锁添加唯一标识","slug":"给锁添加唯一标识","link":"#给锁添加唯一标识","children":[]},{"level":3,"title":"删除锁 原子性操作","slug":"删除锁-原子性操作","link":"#删除锁-原子性操作","children":[]}]},{"level":2,"title":"Redlock","slug":"redlock","link":"#redlock","children":[]},{"level":2,"title":"Watchdog的设计原则","slug":"watchdog的设计原则","link":"#watchdog的设计原则","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.3,"words":1591},"filePathRelative":"redis/应用篇/Redis分布式锁.md","excerpt":"<h2>锁</h2>\\n<p>锁(lock)是为了解决多个工作流对共享资源的访问出现冲突，锁代表着对公共资源的独占声明，当一个工作流获得锁之后，其他的工作流应当能看到这个资源已经被占用。<strong>所以锁的声明和释放一定要基于各个工作流的可见区域来实现</strong>。</p>\\n<p>具体实现方式很多，例如一个进程中的多线程可以利用全局变量在实现；同一个机器的多个进程可以利用共享内存，或者用一个数据库甚至使用一个文件来实现，但是不管怎么实现都要保证如下几点：</p>\\n<ul>\\n<li>互斥性：同一时刻，一个锁只能被一个工作流持有</li>\\n<li>避免死锁：避免持有锁的工作流因为故障无法释放锁，进而使其他工作流永远都无法获得锁</li>\\n</ul>","autoDesc":true}');export{A as comp,B as data};
