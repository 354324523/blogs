import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as r,c as d,d as e,f as t,b as l,e as a}from"./app-DWz5k_-z.js";const n={},c=a('<blockquote><p>当Redis的运行内存已经超过Redis设置的最大内存之后，会使用内存淘汰策略淘汰符合条件的key，以此来保障Redis高效的运行。</p></blockquote><h2 id="redis默认最大运行内存" tabindex="-1"><a class="header-anchor" href="#redis默认最大运行内存"><span>Redis默认最大运行内存</span></a></h2><p>只有在Redis的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，maxmemory的默认值是不同的：</p><ul><li>在64位操作系统中，maxmemory的默认值是0，表示没有内存大小限制，那么不管用户存放多少数据刀Redis中，Redis也不会对可用内存进行检查，知道Redis实例因内存不足崩溃也不做任何操作。</li><li>在32位操作系统中，maxmemory的默认值是3G，因为32位的机器最大只支持4GB的内存，而系统本身又需要一定的内存资源来支持运行，所以32位操作系统限制最大3GB的可用内存是非常合理的，这样可以避免内存不足而导致的Redis实例崩溃。</li></ul><h2 id="如何配置redis最大运行内存" tabindex="-1"><a class="header-anchor" href="#如何配置redis最大运行内存"><span>如何配置Redis最大运行内存？</span></a></h2><p>可以通过以下两种方式配置最大运行内存：</p><ul><li><p>通过 <code>config set maxmemory 1GB</code> 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</p></li><li><p>在配置文件redis.conf中可以通过参数<code>maxmemory &lt;bytes&gt;</code>来设定最大的运行内存，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</p></li></ul><h2 id="redis的内存淘汰策略有哪些" tabindex="-1"><a class="header-anchor" href="#redis的内存淘汰策略有哪些"><span>Redis的内存淘汰策略有哪些？</span></a></h2><p>Redis内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略，可以通过<code>config get maxmemory-policy</code>查看当前内存淘汰策略。</p><ul><li><strong>noeviction</strong>：默认策略，运行内存达到最大设置内存时不淘汰任何数据，如果此时有新数据写入会报错，但是如果没新数据写入，单纯查询或者删除依然可以正常工作。</li><li><strong>volatile-random</strong>：随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>volatile-ttl</strong>：根据键值对象的ttl属性，优先淘汰更早过期的键值。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>volatile-lru</strong>：根据LRU算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>volatile-lfu</strong>：根据LFU算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>allkeys-random</strong>：随机删除所有键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>allkeys-lru</strong>：根据LRU算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li><li><strong>allkeys-lfu</strong>：根据LFU算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象且内存还是不够用时，则报错。</li></ul><h2 id="如何配置redis内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#如何配置redis内存淘汰策略"><span>如何配置Redis内存淘汰策略</span></a></h2><ul><li>通过 <code>config set maxmemory-policy &lt;策略&gt;</code> 命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li><li>通过修改 Redis 配置文件修改，设置 <code>maxmemory-policy &lt;策略&gt;</code>，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li></ul><h2 id="lru算法和lfu算法有什么区别" tabindex="-1"><a class="header-anchor" href="#lru算法和lfu算法有什么区别"><span>LRU算法和LFU算法有什么区别？</span></a></h2><blockquote><p>LRU算法</p></blockquote><blockquote><p>LFU算法</p></blockquote><blockquote><p>Redis如何管理热数据</p></blockquote><h4 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接：</span></a></h4>',17),p={href:"https://xiaolincoding.com/redis/module/strategy.html#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5",target:"_blank",rel:"noopener noreferrer"},m={href:"https://mp.weixin.qq.com/s/-caMTrOXQu-o0O44e6I9dQ",target:"_blank",rel:"noopener noreferrer"};function h(u,R){const i=o("ExternalLinkIcon");return r(),d("div",null,[c,e("blockquote",null,[e("p",null,[e("a",p,[t("Redis过期删除策略"),l(i)])]),e("p",null,[e("a",m,[t("内存耗尽后Redis会发生什么？"),l(i)])])])])}const f=s(n,[["render",h],["__file","内存淘汰策略.html.vue"]]),x=JSON.parse('{"path":"/redis/%E7%AD%96%E7%95%A5%E7%AF%87/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html","title":"Redis内存淘汰策略","lang":"zh-CN","frontmatter":{"title":"Redis内存淘汰策略","order":2,"category":["Redis"],"description":"当Redis的运行内存已经超过Redis设置的最大内存之后，会使用内存淘汰策略淘汰符合条件的key，以此来保障Redis高效的运行。 Redis默认最大运行内存 只有在Redis的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，maxmemory的默认值是不同的： 在64位操作系统中，maxmemory的默认值是0，表示...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/blogs/redis/%E7%AD%96%E7%95%A5%E7%AF%87/%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"皮卡丘"}],["meta",{"property":"og:title","content":"Redis内存淘汰策略"}],["meta",{"property":"og:description","content":"当Redis的运行内存已经超过Redis设置的最大内存之后，会使用内存淘汰策略淘汰符合条件的key，以此来保障Redis高效的运行。 Redis默认最大运行内存 只有在Redis的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，maxmemory的默认值是不同的： 在64位操作系统中，maxmemory的默认值是0，表示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"皮卡丘"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis内存淘汰策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"皮卡丘\\",\\"url\\":\\"https://www.baidu.com\\"}]}"]]},"headers":[{"level":2,"title":"Redis默认最大运行内存","slug":"redis默认最大运行内存","link":"#redis默认最大运行内存","children":[]},{"level":2,"title":"如何配置Redis最大运行内存？","slug":"如何配置redis最大运行内存","link":"#如何配置redis最大运行内存","children":[]},{"level":2,"title":"Redis的内存淘汰策略有哪些？","slug":"redis的内存淘汰策略有哪些","link":"#redis的内存淘汰策略有哪些","children":[]},{"level":2,"title":"如何配置Redis内存淘汰策略","slug":"如何配置redis内存淘汰策略","link":"#如何配置redis内存淘汰策略","children":[]},{"level":2,"title":"LRU算法和LFU算法有什么区别？","slug":"lru算法和lfu算法有什么区别","link":"#lru算法和lfu算法有什么区别","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.49,"words":1048},"filePathRelative":"redis/策略篇/内存淘汰策略.md","excerpt":"<blockquote>\\n<p>当Redis的运行内存已经超过Redis设置的最大内存之后，会使用内存淘汰策略淘汰符合条件的key，以此来保障Redis高效的运行。</p>\\n</blockquote>\\n<h2>Redis默认最大运行内存</h2>\\n<p>只有在Redis的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略。不同位数的操作系统，maxmemory的默认值是不同的：</p>\\n<ul>\\n<li>在64位操作系统中，maxmemory的默认值是0，表示没有内存大小限制，那么不管用户存放多少数据刀Redis中，Redis也不会对可用内存进行检查，知道Redis实例因内存不足崩溃也不做任何操作。</li>\\n<li>在32位操作系统中，maxmemory的默认值是3G，因为32位的机器最大只支持4GB的内存，而系统本身又需要一定的内存资源来支持运行，所以32位操作系统限制最大3GB的可用内存是非常合理的，这样可以避免内存不足而导致的Redis实例崩溃。</li>\\n</ul>","autoDesc":true}');export{f as comp,x as data};
